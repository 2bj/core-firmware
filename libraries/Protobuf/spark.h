/******************************************************************* 
 * Header file generated by Protoc for Embedded C.                 *
 * Version 1.0M4 (2013-03-31)                                      *
 *                                                                 *
 * Copyright (c) 2009-2013                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : Spark.proto
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#ifndef _Spark_H
#define _Spark_H

#ifdef __cplusplus
  extern "C" {
#endif

#define MAX_BYTES_LENGTH 127
#define MAX_STRING_LENGTH 127

/*******************************************************************
 * General functions
 *******************************************************************/

/*
 * returns the size of a length delimited message which also 
 * contains the first bytes for the length encoding.
 */
unsigned long Message_get_delimited_size(void *_buffer, int offset);

/*
 * Tests whether a message can be completely read from the given buffer at
 * the offset. The bytes [offset..offset+length-1] are interpreted.
 *
 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
 * message or 0 (false) otherwise.
 */
int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length);


/*******************************************************************
 * Enumeration: Spark.proto, line 64
 *******************************************************************/
enum Type {
    _CHUNK = 1,
    _CHUNKRECEIVED = 2,
    _EVENT = 3,
    _FUNCTIONCALL = 4,
    _FUNCTIONRETURN = 5,
    _HELLO = 6,
    _IGNORED = 7,
    _KEYCHANGE = 8,
    _UPDATEBEGIN = 9,
    _UPDATEDONE = 10,
    _UPDATEREADY = 11,
    _VARIABLEREQUEST = 12,
    _VARIABLEVALUE = 13
};



/*******************************************************************
 * Message: Spark.proto, line 6
 *******************************************************************/

/* Maximum size of a serialized Chunk-message, useful for buffer allocation. */
#define MAX_Chunk_SIZE 269

/* Structure that holds a deserialized Chunk-message. */
struct Chunk {
    int _crc_len;
    char _crc[MAX_BYTES_LENGTH];
    unsigned long _length;
    int _data_len;
    char _data[MAX_BYTES_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Chunk_write_delimited_to(struct Chunk *_Chunk, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Chunk_write_with_tag(struct Chunk *_Chunk, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Chunk_read_delimited_from(void *_buffer, struct Chunk *_Chunk, int offset);


/*******************************************************************
 * Message: Spark.proto, line 11
 *******************************************************************/

/* Maximum size of a serialized ChunkReceived-message, useful for buffer allocation. */
#define MAX_ChunkReceived_SIZE 139

/* Structure that holds a deserialized ChunkReceived-message. */
struct ChunkReceived {
    unsigned long _counter;
    int _crc_len;
    char _crc[MAX_BYTES_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int ChunkReceived_write_delimited_to(struct ChunkReceived *_ChunkReceived, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int ChunkReceived_write_with_tag(struct ChunkReceived *_ChunkReceived, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int ChunkReceived_read_delimited_from(void *_buffer, struct ChunkReceived *_ChunkReceived, int offset);


/*******************************************************************
 * Message: Spark.proto, line 15
 *******************************************************************/

/* Maximum size of a serialized Event-message, useful for buffer allocation. */
#define MAX_Event_SIZE 269

/* Structure that holds a deserialized Event-message. */
struct Event {
    unsigned long _counter;
    int _name_len;
    char _name[MAX_STRING_LENGTH];
    int _data_len;
    char _data[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Event_write_delimited_to(struct Event *_Event, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Event_write_with_tag(struct Event *_Event, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Event_read_delimited_from(void *_buffer, struct Event *_Event, int offset);


/*******************************************************************
 * Message: Spark.proto, line 20
 *******************************************************************/

/* Maximum size of a serialized FunctionCall-message, useful for buffer allocation. */
#define MAX_FunctionCall_SIZE 9

/* Structure that holds a deserialized FunctionCall-message. */
struct FunctionCall {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int FunctionCall_write_delimited_to(struct FunctionCall *_FunctionCall, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int FunctionCall_write_with_tag(struct FunctionCall *_FunctionCall, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int FunctionCall_read_delimited_from(void *_buffer, struct FunctionCall *_FunctionCall, int offset);


/*******************************************************************
 * Message: Spark.proto, line 24
 *******************************************************************/

/* Maximum size of a serialized FunctionReturn-message, useful for buffer allocation. */
#define MAX_FunctionReturn_SIZE 9

/* Structure that holds a deserialized FunctionReturn-message. */
struct FunctionReturn {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int FunctionReturn_write_delimited_to(struct FunctionReturn *_FunctionReturn, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int FunctionReturn_write_with_tag(struct FunctionReturn *_FunctionReturn, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int FunctionReturn_read_delimited_from(void *_buffer, struct FunctionReturn *_FunctionReturn, int offset);


/*******************************************************************
 * Message: Spark.proto, line 29
 *******************************************************************/

/* Maximum size of a serialized Hello-message, useful for buffer allocation. */
#define MAX_Hello_SIZE 9

/* Structure that holds a deserialized Hello-message. */
struct Hello {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Hello_write_delimited_to(struct Hello *_Hello, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Hello_write_with_tag(struct Hello *_Hello, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Hello_read_delimited_from(void *_buffer, struct Hello *_Hello, int offset);


/*******************************************************************
 * Message: Spark.proto, line 32
 *******************************************************************/

/* Maximum size of a serialized Ignored-message, useful for buffer allocation. */
#define MAX_Ignored_SIZE 16

/* Structure that holds a deserialized Ignored-message. */
struct Ignored {
    unsigned long _counter;
    unsigned long _received;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Ignored_write_delimited_to(struct Ignored *_Ignored, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Ignored_write_with_tag(struct Ignored *_Ignored, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Ignored_read_delimited_from(void *_buffer, struct Ignored *_Ignored, int offset);


/*******************************************************************
 * Message: Spark.proto, line 36
 *******************************************************************/

/* Maximum size of a serialized KeyChange-message, useful for buffer allocation. */
#define MAX_KeyChange_SIZE 269

/* Structure that holds a deserialized KeyChange-message. */
struct KeyChange {
    unsigned long _counter;
    int _ciphertext_len;
    char _ciphertext[MAX_BYTES_LENGTH];
    int _signature_len;
    char _signature[MAX_BYTES_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int KeyChange_write_delimited_to(struct KeyChange *_KeyChange, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int KeyChange_write_with_tag(struct KeyChange *_KeyChange, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int KeyChange_read_delimited_from(void *_buffer, struct KeyChange *_KeyChange, int offset);


/*******************************************************************
 * Message: Spark.proto, line 41
 *******************************************************************/

/* Maximum size of a serialized UpdateBegin-message, useful for buffer allocation. */
#define MAX_UpdateBegin_SIZE 9

/* Structure that holds a deserialized UpdateBegin-message. */
struct UpdateBegin {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int UpdateBegin_write_delimited_to(struct UpdateBegin *_UpdateBegin, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int UpdateBegin_write_with_tag(struct UpdateBegin *_UpdateBegin, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int UpdateBegin_read_delimited_from(void *_buffer, struct UpdateBegin *_UpdateBegin, int offset);


/*******************************************************************
 * Message: Spark.proto, line 44
 *******************************************************************/

/* Maximum size of a serialized UpdateDone-message, useful for buffer allocation. */
#define MAX_UpdateDone_SIZE 9

/* Structure that holds a deserialized UpdateDone-message. */
struct UpdateDone {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int UpdateDone_write_delimited_to(struct UpdateDone *_UpdateDone, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int UpdateDone_write_with_tag(struct UpdateDone *_UpdateDone, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int UpdateDone_read_delimited_from(void *_buffer, struct UpdateDone *_UpdateDone, int offset);


/*******************************************************************
 * Message: Spark.proto, line 47
 *******************************************************************/

/* Maximum size of a serialized UpdateReady-message, useful for buffer allocation. */
#define MAX_UpdateReady_SIZE 9

/* Structure that holds a deserialized UpdateReady-message. */
struct UpdateReady {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int UpdateReady_write_delimited_to(struct UpdateReady *_UpdateReady, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int UpdateReady_write_with_tag(struct UpdateReady *_UpdateReady, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int UpdateReady_read_delimited_from(void *_buffer, struct UpdateReady *_UpdateReady, int offset);


/*******************************************************************
 * Message: Spark.proto, line 50
 *******************************************************************/

/* Maximum size of a serialized VariableRequest-message, useful for buffer allocation. */
#define MAX_VariableRequest_SIZE 9

/* Structure that holds a deserialized VariableRequest-message. */
struct VariableRequest {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int VariableRequest_write_delimited_to(struct VariableRequest *_VariableRequest, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int VariableRequest_write_with_tag(struct VariableRequest *_VariableRequest, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int VariableRequest_read_delimited_from(void *_buffer, struct VariableRequest *_VariableRequest, int offset);


/*******************************************************************
 * Message: Spark.proto, line 54
 *******************************************************************/

/* Maximum size of a serialized VariableValue-message, useful for buffer allocation. */
#define MAX_VariableValue_SIZE 9

/* Structure that holds a deserialized VariableValue-message. */
struct VariableValue {
    unsigned long _counter;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int VariableValue_write_delimited_to(struct VariableValue *_VariableValue, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int VariableValue_write_with_tag(struct VariableValue *_VariableValue, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int VariableValue_read_delimited_from(void *_buffer, struct VariableValue *_VariableValue, int offset);


/*******************************************************************
 * Message: Spark.proto, line 80
 *******************************************************************/

/* Maximum size of a serialized Envelope-message, useful for buffer allocation. */
#define MAX_Envelope_SIZE 1039

/* Structure that holds a deserialized Envelope-message. */
struct Envelope {
    enum Type _type;
    struct VariableRequest _variablerequest;
    struct VariableValue _variablevalue;
    struct FunctionCall _functioncall;
    struct FunctionReturn _functionreturn;
    struct Event _event;
    struct Ignored _ignored;
    struct UpdateBegin _updatebegin;
    struct UpdateReady _updateready;
    struct Chunk _chunk;
    struct ChunkReceived _chunkreceived;
    struct UpdateDone _updatedone;
    struct Hello _hello;
    struct KeyChange _keychange;
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int Envelope_write_delimited_to(struct Envelope *_Envelope, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int Envelope_write_with_tag(struct Envelope *_Envelope, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int Envelope_read_delimited_from(void *_buffer, struct Envelope *_Envelope, int offset);



#ifdef __cplusplus
  }
#endif

#endif

