/******************************************************************* 
 * C file generated by Protoc for Embedded C.                      *
 * Version 1.0M4 (2013-03-31)                                      *
 *                                                                 *
 * Copyright (c) 2009-2013                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : key_change.proto
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/
 
#include "Key_change.h"

/*******************************************************************
 * Message: Key_change.proto, line 5
 *******************************************************************/

void KeyChange_clear(struct KeyChange *_KeyChange) {
	_memset(_KeyChange, 0, sizeof(struct KeyChange));
}

void KeyChange_init_optional_attributes(struct KeyChange *_KeyChange) {
	_KeyChange->_counter = 0;
	
	_KeyChange->_ciphertext_len = 0;
	
	
	_KeyChange->_signature_len = 0;
	
	
}

int KeyChange_is_default_message(struct KeyChange *_KeyChange) {
    return _KeyChange->_counter == 0
    
     && _KeyChange->_ciphertext_len == 0
    
     && _KeyChange->_signature_len == 0
    ;
}

int KeyChange_write(struct KeyChange *_KeyChange, void *_buffer, int offset) {
	/* Write content of each message element.*/
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_counter != 0) {
		offset = write_raw_varint32((1<<3)+0, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_counter, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_ciphertext_len != 1
	    || _KeyChange->_ciphertext[0] != '0') {
		offset = write_raw_varint32((2<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_ciphertext_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_ciphertext, _KeyChange->_ciphertext_len, _buffer, offset);
	}
	
	/* Write the optional attribute only if it is different than the default value. */
	if(_KeyChange->_signature_len != 1
	    || _KeyChange->_signature[0] != '0') {
		offset = write_raw_varint32((3<<3)+2, _buffer, offset);
	    offset = write_raw_varint32(_KeyChange->_signature_len, _buffer, offset);
	    offset = write_raw_bytes(_KeyChange->_signature, _KeyChange->_signature_len, _buffer, offset);
	}
	
	return offset;
}

int KeyChange_write_with_tag(struct KeyChange *_KeyChange, void *_buffer, int offset, int tag) {
	/* Write tag.*/
	offset = write_raw_varint32((tag<<3)+2, _buffer, offset);
	/* Write content.*/
	offset = KeyChange_write_delimited_to(_KeyChange, _buffer, offset);
	
	return offset;
}

int KeyChange_write_delimited_to(struct KeyChange *_KeyChange, void *_buffer, int offset) {
	int i, shift, new_offset, size;
	
	new_offset = KeyChange_write(_KeyChange, _buffer, offset);
	size = new_offset - offset;
	shift = (size > 127) ? 2 : 1;
	for (i = new_offset - 1; i >= offset; -- i)
	    *((char *)_buffer + i + shift) = *((char *)_buffer + i);
	
	write_raw_varint32((unsigned long) size, _buffer, offset);         
	    
	return new_offset + shift;
}

int KeyChange_read(void *_buffer, struct KeyChange *_KeyChange, int offset, int limit) {
	unsigned int i = 0;
	unsigned long long value = i;
	unsigned long tag = value;
	
	/* Reset all attributes to 0 in advance. */
	KeyChange_clear(_KeyChange);
	/* Assign the optional attributes. */
	KeyChange_init_optional_attributes(_KeyChange);
	
	/* Read/interpret all attributes from buffer offset until upper limit is reached. */
	while(offset < limit) {
	    offset = read_raw_varint32(&tag, _buffer, offset);
		tag = tag>>3;
	    switch(tag){
	        /* tag of: _KeyChange._counter */
	        case 1 :
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_counter = tag;
	        	break;
	        /* tag of: _KeyChange._ciphertext */
	        case 2 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_ciphertext_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_ciphertext + i), _buffer, offset);
	        	break;
	        /* tag of: _KeyChange._signature */
	        case 3 :
	        	/* Re-use 'tag' to store string length. */
	        	offset = read_raw_varint32(&tag, _buffer, offset);
	        	_KeyChange->_signature_len = tag;
	        	for(i = 0; i < tag; ++ i) 
	        	    offset = read_raw_byte((_KeyChange->_signature + i), _buffer, offset);
	        	break;
	    }
	}
	
	return offset;
}

int KeyChange_read_delimited_from(void *_buffer, struct KeyChange *_KeyChange, int offset) {
	unsigned long size;
	
	offset = read_raw_varint32(&size, _buffer, offset);
	KeyChange_read(_buffer, _KeyChange, offset, size + offset);
	
	return offset + size;
}
