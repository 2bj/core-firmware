   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"cc3000_spi.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	wlan_rx_buffer,1024,4
  19              		.comm	wlan_tx_buffer,1024,4
  20              		.comm	sSpiInformation,20,4
  21              		.global	tSpiReadHeader
  22              		.data
  23              		.align	2
  26              	tSpiReadHeader:
  27 0000 03       		.byte	3
  28 0001 00       		.byte	0
  29 0002 00       		.byte	0
  30 0003 00       		.byte	0
  31 0004 00       		.byte	0
  32 0005 000000   		.section	.text.SysCtlDelay,"ax",%progbits
  33              		.align	2
  34              		.global	SysCtlDelay
  35              		.thumb
  36              		.thumb_func
  38              	SysCtlDelay:
  39              	.LFB56:
  40              		.file 1 "../src/cc3000_spi.c"
   1:../src/cc3000_spi.c **** /**
   2:../src/cc3000_spi.c ****   ******************************************************************************
   3:../src/cc3000_spi.c ****   * @file    cc3000_spi.c
   4:../src/cc3000_spi.c ****   * @author  Spark Application Team
   5:../src/cc3000_spi.c ****   * @version V1.0.0
   6:../src/cc3000_spi.c ****   * @date    29-March-2013
   7:../src/cc3000_spi.c ****   * @brief   This file contains all the functions prototypes for the
   8:../src/cc3000_spi.c ****   *          CC3000 SPI firmware driver.
   9:../src/cc3000_spi.c ****   ******************************************************************************
  10:../src/cc3000_spi.c ****   */
  11:../src/cc3000_spi.c **** 
  12:../src/cc3000_spi.c **** #include "cc3000_spi.h"
  13:../src/cc3000_spi.c **** 
  14:../src/cc3000_spi.c **** unsigned char wlan_rx_buffer[SPI_BUFFER_SIZE];	//CC3000_RX_BUFFER_SIZE
  15:../src/cc3000_spi.c **** unsigned char wlan_tx_buffer[SPI_BUFFER_SIZE];	//CC3000_TX_BUFFER_SIZE
  16:../src/cc3000_spi.c **** 
  17:../src/cc3000_spi.c **** #define eSPI_STATE_POWERUP				(0)
  18:../src/cc3000_spi.c **** #define eSPI_STATE_INITIALIZED			(1)
  19:../src/cc3000_spi.c **** #define eSPI_STATE_IDLE					(2)
  20:../src/cc3000_spi.c **** #define eSPI_STATE_WRITE_IRQ			(3)
  21:../src/cc3000_spi.c **** #define eSPI_STATE_WRITE_FIRST_PORTION	(4)
  22:../src/cc3000_spi.c **** #define eSPI_STATE_WRITE_EOT			(5)
  23:../src/cc3000_spi.c **** #define eSPI_STATE_READ_IRQ				(6)
  24:../src/cc3000_spi.c **** #define eSPI_STATE_READ_FIRST_PORTION	(7)
  25:../src/cc3000_spi.c **** #define eSPI_STATE_READ_EOT				(8)
  26:../src/cc3000_spi.c **** 
  27:../src/cc3000_spi.c **** typedef struct
  28:../src/cc3000_spi.c **** {
  29:../src/cc3000_spi.c **** 	gcSpiHandleRx SPIRxHandler;
  30:../src/cc3000_spi.c **** 	unsigned short usTxPacketLength;
  31:../src/cc3000_spi.c **** 	unsigned short usRxPacketLength;
  32:../src/cc3000_spi.c **** 	volatile unsigned long ulSpiState;
  33:../src/cc3000_spi.c **** 	unsigned char *pTxPacket;
  34:../src/cc3000_spi.c **** 	unsigned char *pRxPacket;
  35:../src/cc3000_spi.c **** } tSpiInformation;
  36:../src/cc3000_spi.c **** 
  37:../src/cc3000_spi.c **** tSpiInformation sSpiInformation;
  38:../src/cc3000_spi.c **** 
  39:../src/cc3000_spi.c **** // Static buffer for 5 bytes of SPI HEADER
  40:../src/cc3000_spi.c **** unsigned char tSpiReadHeader[] = { READ, 0, 0, 0, 0 };
  41:../src/cc3000_spi.c **** 
  42:../src/cc3000_spi.c **** void SpiPauseSpi(void);
  43:../src/cc3000_spi.c **** void SpiReadData(unsigned char *data, unsigned short size);
  44:../src/cc3000_spi.c **** void SpiTriggerRxProcessing(void);
  45:../src/cc3000_spi.c **** void SpiWriteAsync(const unsigned char *data, unsigned short size);
  46:../src/cc3000_spi.c **** void SpiReadWriteStringInt(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize);
  47:../src/cc3000_spi.c **** void SpiReadWriteString(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize);
  48:../src/cc3000_spi.c **** long SpiFirstWrite(unsigned char *ucBuf, unsigned short usLength);
  49:../src/cc3000_spi.c **** long SpiReadDataCont(void);
  50:../src/cc3000_spi.c **** void SpiReadHeader(void);
  51:../src/cc3000_spi.c **** void SpiContReadOperation(void);
  52:../src/cc3000_spi.c **** 
  53:../src/cc3000_spi.c **** /**
  54:../src/cc3000_spi.c ****  * @brief  The functions delay for a number of MCU clk period
  55:../src/cc3000_spi.c ****  * @param  The number of MCU clk period to delay for
  56:../src/cc3000_spi.c ****  * @retval None
  57:../src/cc3000_spi.c ****  */
  58:../src/cc3000_spi.c **** inline void SysCtlDelay(unsigned long ulDelay)
  59:../src/cc3000_spi.c **** {
  41              		.loc 1 59 0
  42              		.cfi_startproc
  43              		@ args = 0, pretend = 0, frame = 8
  44              		@ frame_needed = 1, uses_anonymous_args = 0
  45              		@ link register save eliminated.
  46 0000 80B4     		push	{r7}
  47              	.LCFI0:
  48              		.cfi_def_cfa_offset 4
  49              		.cfi_offset 7, -4
  50 0002 83B0     		sub	sp, sp, #12
  51              	.LCFI1:
  52              		.cfi_def_cfa_offset 16
  53 0004 00AF     		add	r7, sp, #0
  54              	.LCFI2:
  55              		.cfi_def_cfa_register 7
  56 0006 7860     		str	r0, [r7, #4]
  60:../src/cc3000_spi.c **** 	/* Decrement nCount value */
  61:../src/cc3000_spi.c **** 	while (ulDelay != 0)
  57              		.loc 1 61 0
  58 0008 03E0     		b	.L2
  59              	.L3:
  62:../src/cc3000_spi.c **** 	{
  63:../src/cc3000_spi.c **** 		ulDelay--;
  60              		.loc 1 63 0
  61 000a 7B68     		ldr	r3, [r7, #4]
  62 000c 03F1FF33 		add	r3, r3, #-1
  63 0010 7B60     		str	r3, [r7, #4]
  64              	.L2:
  61:../src/cc3000_spi.c **** 	while (ulDelay != 0)
  65              		.loc 1 61 0 discriminator 1
  66 0012 7B68     		ldr	r3, [r7, #4]
  67 0014 002B     		cmp	r3, #0
  68 0016 F8D1     		bne	.L3
  64:../src/cc3000_spi.c **** 	}
  65:../src/cc3000_spi.c **** }
  69              		.loc 1 65 0
  70 0018 07F10C07 		add	r7, r7, #12
  71 001c BD46     		mov	sp, r7
  72 001e 80BC     		pop	{r7}
  73 0020 7047     		bx	lr
  74              		.cfi_endproc
  75              	.LFE56:
  77 0022 00BF     		.section	.text.SpiOpen,"ax",%progbits
  78              		.align	2
  79              		.global	SpiOpen
  80              		.thumb
  81              		.thumb_func
  83              	SpiOpen:
  84              	.LFB57:
  66:../src/cc3000_spi.c **** 
  67:../src/cc3000_spi.c **** /****************************************************************************
  68:../src/cc3000_spi.c ****  CC3000 SPI Protocol API
  69:../src/cc3000_spi.c ****  ****************************************************************************/
  70:../src/cc3000_spi.c **** void SpiOpen(gcSpiHandleRx pfRxHandler)
  71:../src/cc3000_spi.c **** {
  85              		.loc 1 71 0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 8
  88              		@ frame_needed = 1, uses_anonymous_args = 0
  89 0000 80B5     		push	{r7, lr}
  90              	.LCFI3:
  91              		.cfi_def_cfa_offset 8
  92              		.cfi_offset 7, -8
  93              		.cfi_offset 14, -4
  94 0002 82B0     		sub	sp, sp, #8
  95              	.LCFI4:
  96              		.cfi_def_cfa_offset 16
  97 0004 00AF     		add	r7, sp, #0
  98              	.LCFI5:
  99              		.cfi_def_cfa_register 7
 100 0006 7860     		str	r0, [r7, #4]
  72:../src/cc3000_spi.c **** 	sSpiInformation.ulSpiState = eSPI_STATE_POWERUP;
 101              		.loc 1 72 0
 102 0008 40F20003 		movw	r3, #:lower16:sSpiInformation
 103 000c C0F20003 		movt	r3, #:upper16:sSpiInformation
 104 0010 4FF00002 		mov	r2, #0
 105 0014 9A60     		str	r2, [r3, #8]
  73:../src/cc3000_spi.c **** 
  74:../src/cc3000_spi.c **** 	sSpiInformation.SPIRxHandler = pfRxHandler;
 106              		.loc 1 74 0
 107 0016 40F20003 		movw	r3, #:lower16:sSpiInformation
 108 001a C0F20003 		movt	r3, #:upper16:sSpiInformation
 109 001e 7A68     		ldr	r2, [r7, #4]
 110 0020 1A60     		str	r2, [r3, #0]
  75:../src/cc3000_spi.c **** 	sSpiInformation.pRxPacket = wlan_rx_buffer;
 111              		.loc 1 75 0
 112 0022 40F20003 		movw	r3, #:lower16:sSpiInformation
 113 0026 C0F20003 		movt	r3, #:upper16:sSpiInformation
 114 002a 40F20002 		movw	r2, #:lower16:wlan_rx_buffer
 115 002e C0F20002 		movt	r2, #:upper16:wlan_rx_buffer
 116 0032 1A61     		str	r2, [r3, #16]
  76:../src/cc3000_spi.c **** 	sSpiInformation.usRxPacketLength = 0;
 117              		.loc 1 76 0
 118 0034 40F20003 		movw	r3, #:lower16:sSpiInformation
 119 0038 C0F20003 		movt	r3, #:upper16:sSpiInformation
 120 003c 4FF00002 		mov	r2, #0
 121 0040 DA80     		strh	r2, [r3, #6]	@ movhi
  77:../src/cc3000_spi.c **** 	sSpiInformation.pTxPacket = NULL;
 122              		.loc 1 77 0
 123 0042 40F20003 		movw	r3, #:lower16:sSpiInformation
 124 0046 C0F20003 		movt	r3, #:upper16:sSpiInformation
 125 004a 4FF00002 		mov	r2, #0
 126 004e DA60     		str	r2, [r3, #12]
  78:../src/cc3000_spi.c **** 	sSpiInformation.usTxPacketLength = 0;
 127              		.loc 1 78 0
 128 0050 40F20003 		movw	r3, #:lower16:sSpiInformation
 129 0054 C0F20003 		movt	r3, #:upper16:sSpiInformation
 130 0058 4FF00002 		mov	r2, #0
 131 005c 9A80     		strh	r2, [r3, #4]	@ movhi
  79:../src/cc3000_spi.c **** 
  80:../src/cc3000_spi.c **** 	/* Enable Interrupt */
  81:../src/cc3000_spi.c **** 	tSLInformation.WlanInterruptEnable();
 132              		.loc 1 81 0
 133 005e 40F20003 		movw	r3, #:lower16:tSLInformation
 134 0062 C0F20003 		movt	r3, #:upper16:tSLInformation
 135 0066 1B6A     		ldr	r3, [r3, #32]
 136 0068 9847     		blx	r3
  82:../src/cc3000_spi.c **** }
 137              		.loc 1 82 0
 138 006a 07F10807 		add	r7, r7, #8
 139 006e BD46     		mov	sp, r7
 140 0070 80BD     		pop	{r7, pc}
 141              		.cfi_endproc
 142              	.LFE57:
 144 0072 00BF     		.section	.text.SpiClose,"ax",%progbits
 145              		.align	2
 146              		.global	SpiClose
 147              		.thumb
 148              		.thumb_func
 150              	SpiClose:
 151              	.LFB58:
  83:../src/cc3000_spi.c **** 
  84:../src/cc3000_spi.c **** void SpiClose(void)
  85:../src/cc3000_spi.c **** {
 152              		.loc 1 85 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 0
 155              		@ frame_needed = 1, uses_anonymous_args = 0
 156 0000 80B5     		push	{r7, lr}
 157              	.LCFI6:
 158              		.cfi_def_cfa_offset 8
 159              		.cfi_offset 7, -8
 160              		.cfi_offset 14, -4
 161 0002 00AF     		add	r7, sp, #0
 162              	.LCFI7:
 163              		.cfi_def_cfa_register 7
  86:../src/cc3000_spi.c **** 	if (sSpiInformation.pRxPacket)
 164              		.loc 1 86 0
 165 0004 40F20003 		movw	r3, #:lower16:sSpiInformation
 166 0008 C0F20003 		movt	r3, #:upper16:sSpiInformation
 167 000c 1B69     		ldr	r3, [r3, #16]
 168 000e 002B     		cmp	r3, #0
 169 0010 06D0     		beq	.L6
  87:../src/cc3000_spi.c **** 	{
  88:../src/cc3000_spi.c **** 		sSpiInformation.pRxPacket = 0;
 170              		.loc 1 88 0
 171 0012 40F20003 		movw	r3, #:lower16:sSpiInformation
 172 0016 C0F20003 		movt	r3, #:upper16:sSpiInformation
 173 001a 4FF00002 		mov	r2, #0
 174 001e 1A61     		str	r2, [r3, #16]
 175              	.L6:
  89:../src/cc3000_spi.c **** 	}
  90:../src/cc3000_spi.c **** 
  91:../src/cc3000_spi.c **** 	/* Disable Interrupt */
  92:../src/cc3000_spi.c **** 	tSLInformation.WlanInterruptDisable();
 176              		.loc 1 92 0
 177 0020 40F20003 		movw	r3, #:lower16:tSLInformation
 178 0024 C0F20003 		movt	r3, #:upper16:tSLInformation
 179 0028 5B6A     		ldr	r3, [r3, #36]
 180 002a 9847     		blx	r3
  93:../src/cc3000_spi.c **** }
 181              		.loc 1 93 0
 182 002c 80BD     		pop	{r7, pc}
 183              		.cfi_endproc
 184              	.LFE58:
 186 002e 00BF     		.section	.text.SpiResumeSpi,"ax",%progbits
 187              		.align	2
 188              		.global	SpiResumeSpi
 189              		.thumb
 190              		.thumb_func
 192              	SpiResumeSpi:
 193              	.LFB59:
  94:../src/cc3000_spi.c **** 
  95:../src/cc3000_spi.c **** void SpiResumeSpi(void)
  96:../src/cc3000_spi.c **** {
 194              		.loc 1 96 0
 195              		.cfi_startproc
 196              		@ args = 0, pretend = 0, frame = 0
 197              		@ frame_needed = 1, uses_anonymous_args = 0
 198              		@ link register save eliminated.
 199 0000 80B4     		push	{r7}
 200              	.LCFI8:
 201              		.cfi_def_cfa_offset 4
 202              		.cfi_offset 7, -4
 203 0002 00AF     		add	r7, sp, #0
 204              	.LCFI9:
 205              		.cfi_def_cfa_register 7
 206              	.LBB6:
 207              	.LBB7:
 208              		.file 2 "/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h"
   1:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /**************************************************************************//**
   2:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * @file     core_cmFunc.h
   3:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * @brief    CMSIS Cortex-M Core Function Access Header File
   4:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * @version  V3.01
   5:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * @date     06. March 2012
   6:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  *
   7:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * @note
   8:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
   9:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  *
  10:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * @par
  11:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * ARM Limited (ARM) is supplying this software for use with Cortex-M
  12:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * processor based microcontrollers.  This file can be freely distributed
  13:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * within development tools that are supporting such ARM based processors.
  14:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  *
  15:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * @par
  16:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  17:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  18:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
  19:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
  20:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  21:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  *
  22:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  ******************************************************************************/
  23:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  24:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #ifndef __CORE_CMFUNC_H
  25:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #define __CORE_CMFUNC_H
  26:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  27:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  28:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /* ###########################  Core Function Access  ########################### */
  29:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  30:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  31:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   @{
  32:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
  33:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  34:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  35:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /* ARM armcc specific functions */
  36:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  37:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #if (__ARMCC_VERSION < 400677)
  38:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  39:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #endif
  40:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  41:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /* intrinsic void __enable_irq();     */
  42:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /* intrinsic void __disable_irq();    */
  43:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  44:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Control Register
  45:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  46:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the Control Register.
  47:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  48:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               Control Register value
  49:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
  50:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_CONTROL(void)
  51:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
  52:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  53:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regControl);
  54:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
  55:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  56:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  57:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Control Register
  58:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  59:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function writes the given value to the Control Register.
  60:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  61:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \param [in]    control  Control Register value to set
  62:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
  63:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_CONTROL(uint32_t control)
  64:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
  65:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  66:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __regControl = control;
  67:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
  68:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  69:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  70:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get IPSR Register
  71:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  72:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the IPSR Register.
  73:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  74:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               IPSR Register value
  75:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
  76:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_IPSR(void)
  77:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
  78:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regIPSR          __ASM("ipsr");
  79:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regIPSR);
  80:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
  81:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  82:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  83:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get APSR Register
  84:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  85:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the APSR Register.
  86:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  87:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               APSR Register value
  88:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
  89:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_APSR(void)
  90:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
  91:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regAPSR          __ASM("apsr");
  92:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regAPSR);
  93:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
  94:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  95:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  96:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get xPSR Register
  97:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
  98:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the xPSR Register.
  99:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 100:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               xPSR Register value
 101:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 102:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_xPSR(void)
 103:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 104:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regXPSR          __ASM("xpsr");
 105:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regXPSR);
 106:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 107:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 108:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 109:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Process Stack Pointer
 110:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 111:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Process Stack Pointer (PSP).
 112:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 113:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               PSP Register value
 114:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 115:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PSP(void)
 116:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 117:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 118:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regProcessStackPointer);
 119:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 120:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 121:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 122:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Process Stack Pointer
 123:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 124:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Process Stack Pointer (PSP).
 125:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 126:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfProcStack  Process Stack Pointer value to set
 127:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 128:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 129:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 130:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 131:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __regProcessStackPointer = topOfProcStack;
 132:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 133:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 134:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 135:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Main Stack Pointer
 136:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 137:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Main Stack Pointer (MSP).
 138:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 139:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               MSP Register value
 140:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 141:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_MSP(void)
 142:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 143:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 144:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regMainStackPointer);
 145:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 146:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 147:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 148:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Main Stack Pointer
 149:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 150:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Main Stack Pointer (MSP).
 151:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 152:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 153:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 154:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 155:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 156:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 157:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __regMainStackPointer = topOfMainStack;
 158:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 159:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 160:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 161:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Priority Mask
 162:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 163:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the current state of the priority mask bit from the Priority Mask Registe
 164:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 165:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               Priority Mask value
 166:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 167:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PRIMASK(void)
 168:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 169:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 170:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regPriMask);
 171:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 172:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 173:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 174:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Priority Mask
 175:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 176:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Priority Mask Register.
 177:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 178:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \param [in]    priMask  Priority Mask
 179:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 180:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 181:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 182:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 183:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __regPriMask = (priMask);
 184:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 185:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 186:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 187:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M >= 0x03)
 188:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 189:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Enable FIQ
 190:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 191:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function enables FIQ interrupts by clearing the F-bit in the CPSR.
 192:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 193:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 194:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #define __enable_fault_irq                __enable_fiq
 195:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 196:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 197:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Disable FIQ
 198:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 199:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function disables FIQ interrupts by setting the F-bit in the CPSR.
 200:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 201:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 202:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #define __disable_fault_irq               __disable_fiq
 203:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 204:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 205:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Base Priority
 206:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 207:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Base Priority register.
 208:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 209:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               Base Priority register value
 210:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 211:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t  __get_BASEPRI(void)
 212:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 213:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 214:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regBasePri);
 215:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 216:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 217:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 218:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Base Priority
 219:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 220:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Base Priority register.
 221:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 222:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \param [in]    basePri  Base Priority value to set
 223:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 224:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 225:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 226:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 227:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __regBasePri = (basePri & 0xff);
 228:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 229:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 230:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 231:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Fault Mask
 232:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 233:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Fault Mask register.
 234:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 235:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               Fault Mask register value
 236:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 237:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 238:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 239:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 240:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regFaultMask);
 241:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 242:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 243:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 244:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Fault Mask
 245:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 246:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Fault Mask register.
 247:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 248:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \param [in]    faultMask  Fault Mask value to set
 249:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 250:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 251:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 252:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 253:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __regFaultMask = (faultMask & (uint32_t)1);
 254:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 255:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 256:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M >= 0x03) */
 257:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 258:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 259:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M == 0x04)
 260:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 261:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Get FPSCR
 262:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 263:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Floating Point Status/Control register.
 264:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 265:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \return               Floating Point Status/Control register value
 266:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 267:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FPSCR(void)
 268:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 269:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 270:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 271:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   return(__regfpscr);
 272:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #else
 273:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****    return(0);
 274:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #endif
 275:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 276:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 277:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 278:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Set FPSCR
 279:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 280:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Floating Point Status/Control register.
 281:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 282:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****     \param [in]    fpscr  Floating Point Status/Control value to set
 283:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 284:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 285:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 286:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 287:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 288:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __regfpscr = (fpscr);
 289:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #endif
 290:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 291:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 292:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M == 0x04) */
 293:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 294:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 295:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 296:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /* IAR iccarm specific functions */
 297:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 298:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #include <cmsis_iar.h>
 299:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 300:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 301:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 302:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /* TI CCS specific functions */
 303:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 304:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #include <cmsis_ccs.h>
 305:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 306:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 307:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 308:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /* GNU gcc specific functions */
 309:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 310:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Enable IRQ Interrupts
 311:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 312:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   This function enables IRQ interrupts by clearing the I-bit in the CPSR.
 313:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 314:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 315:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
 316:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 317:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsie i");
 209              		.loc 2 317 0
 210              	@ 317 "/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h" 1
 211 0004 62B6     		cpsie i
 212              	@ 0 "" 2
 213              		.thumb
 214              	.LBE7:
 215              	.LBE6:
  97:../src/cc3000_spi.c **** 	//
  98:../src/cc3000_spi.c **** 	//Enable IRQ Interrupts
  99:../src/cc3000_spi.c **** 	//
 100:../src/cc3000_spi.c **** 	__enable_irq();
 101:../src/cc3000_spi.c **** }
 216              		.loc 1 101 0
 217 0006 BD46     		mov	sp, r7
 218 0008 80BC     		pop	{r7}
 219 000a 7047     		bx	lr
 220              		.cfi_endproc
 221              	.LFE59:
 223              		.section	.text.SpiPauseSpi,"ax",%progbits
 224              		.align	2
 225              		.global	SpiPauseSpi
 226              		.thumb
 227              		.thumb_func
 229              	SpiPauseSpi:
 230              	.LFB60:
 102:../src/cc3000_spi.c **** 
 103:../src/cc3000_spi.c **** void SpiPauseSpi(void)
 104:../src/cc3000_spi.c **** {
 231              		.loc 1 104 0
 232              		.cfi_startproc
 233              		@ args = 0, pretend = 0, frame = 0
 234              		@ frame_needed = 1, uses_anonymous_args = 0
 235              		@ link register save eliminated.
 236 0000 80B4     		push	{r7}
 237              	.LCFI10:
 238              		.cfi_def_cfa_offset 4
 239              		.cfi_offset 7, -4
 240 0002 00AF     		add	r7, sp, #0
 241              	.LCFI11:
 242              		.cfi_def_cfa_register 7
 243              	.LBB8:
 244              	.LBB9:
 318:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** }
 319:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 320:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 321:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** /** \brief  Disable IRQ Interrupts
 322:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** 
 323:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   This function disables IRQ interrupts by setting the I-bit in the CPSR.
 324:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 325:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****  */
 326:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
 327:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h **** {
 328:/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsid i");
 245              		.loc 2 328 0
 246              	@ 328 "/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cmFunc.h" 1
 247 0004 72B6     		cpsid i
 248              	@ 0 "" 2
 249              		.thumb
 250              	.LBE9:
 251              	.LBE8:
 105:../src/cc3000_spi.c **** 	//
 106:../src/cc3000_spi.c **** 	//Disable IRQ Interrupts
 107:../src/cc3000_spi.c **** 	//
 108:../src/cc3000_spi.c **** 	__disable_irq();
 109:../src/cc3000_spi.c **** }
 252              		.loc 1 109 0
 253 0006 BD46     		mov	sp, r7
 254 0008 80BC     		pop	{r7}
 255 000a 7047     		bx	lr
 256              		.cfi_endproc
 257              	.LFE60:
 259              		.section	.text.SpiTriggerRxProcessing,"ax",%progbits
 260              		.align	2
 261              		.global	SpiTriggerRxProcessing
 262              		.thumb
 263              		.thumb_func
 265              	SpiTriggerRxProcessing:
 266              	.LFB61:
 110:../src/cc3000_spi.c **** 
 111:../src/cc3000_spi.c **** /**
 112:../src/cc3000_spi.c ****  * @brief  This indicate the end of a receive and calls a registered handler
 113:../src/cc3000_spi.c ****  to process the received data
 114:../src/cc3000_spi.c ****  * @param  None
 115:../src/cc3000_spi.c ****  * @retval None
 116:../src/cc3000_spi.c ****  */
 117:../src/cc3000_spi.c **** void SpiTriggerRxProcessing(void)
 118:../src/cc3000_spi.c **** {
 267              		.loc 1 118 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 0
 270              		@ frame_needed = 1, uses_anonymous_args = 0
 271 0000 80B5     		push	{r7, lr}
 272              	.LCFI12:
 273              		.cfi_def_cfa_offset 8
 274              		.cfi_offset 7, -8
 275              		.cfi_offset 14, -4
 276 0002 00AF     		add	r7, sp, #0
 277              	.LCFI13:
 278              		.cfi_def_cfa_register 7
 119:../src/cc3000_spi.c **** 	SpiPauseSpi();
 279              		.loc 1 119 0
 280 0004 FFF7FEFF 		bl	SpiPauseSpi
 120:../src/cc3000_spi.c **** 
 121:../src/cc3000_spi.c **** 	//
 122:../src/cc3000_spi.c **** 	// Trigger Rx processing
 123:../src/cc3000_spi.c **** 	//
 124:../src/cc3000_spi.c **** 	DEASSERT_CS();
 281              		.loc 1 124 0
 282 0008 4FF44060 		mov	r0, #3072
 283 000c C4F20100 		movt	r0, 16385
 284 0010 4FF48051 		mov	r1, #4096
 285 0014 FFF7FEFF 		bl	GPIO_SetBits
 125:../src/cc3000_spi.c **** 	sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 286              		.loc 1 125 0
 287 0018 40F20003 		movw	r3, #:lower16:sSpiInformation
 288 001c C0F20003 		movt	r3, #:upper16:sSpiInformation
 289 0020 4FF00202 		mov	r2, #2
 290 0024 9A60     		str	r2, [r3, #8]
 126:../src/cc3000_spi.c **** 	sSpiInformation.SPIRxHandler(sSpiInformation.pRxPacket + SPI_HEADER_SIZE);
 291              		.loc 1 126 0
 292 0026 40F20003 		movw	r3, #:lower16:sSpiInformation
 293 002a C0F20003 		movt	r3, #:upper16:sSpiInformation
 294 002e 1A68     		ldr	r2, [r3, #0]
 295 0030 40F20003 		movw	r3, #:lower16:sSpiInformation
 296 0034 C0F20003 		movt	r3, #:upper16:sSpiInformation
 297 0038 1B69     		ldr	r3, [r3, #16]
 298 003a 03F10503 		add	r3, r3, #5
 299 003e 1846     		mov	r0, r3
 300 0040 9047     		blx	r2
 127:../src/cc3000_spi.c **** }
 301              		.loc 1 127 0
 302 0042 80BD     		pop	{r7, pc}
 303              		.cfi_endproc
 304              	.LFE61:
 306              		.section	.text.SpiReadData,"ax",%progbits
 307              		.align	2
 308              		.global	SpiReadData
 309              		.thumb
 310              		.thumb_func
 312              	SpiReadData:
 313              	.LFB62:
 128:../src/cc3000_spi.c **** 
 129:../src/cc3000_spi.c **** /**
 130:../src/cc3000_spi.c ****  * @brief  Sends data on SPI to generate interrupt on reception
 131:../src/cc3000_spi.c ****  * @param  The pointer to data buffer
 132:../src/cc3000_spi.c ****  * @param  This size of data
 133:../src/cc3000_spi.c ****  * @retval None
 134:../src/cc3000_spi.c ****  */
 135:../src/cc3000_spi.c **** void SpiReadData(unsigned char *data, unsigned short size)
 136:../src/cc3000_spi.c **** {
 314              		.loc 1 136 0
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 8
 317              		@ frame_needed = 1, uses_anonymous_args = 0
 318 0000 80B5     		push	{r7, lr}
 319              	.LCFI14:
 320              		.cfi_def_cfa_offset 8
 321              		.cfi_offset 7, -8
 322              		.cfi_offset 14, -4
 323 0002 82B0     		sub	sp, sp, #8
 324              	.LCFI15:
 325              		.cfi_def_cfa_offset 16
 326 0004 00AF     		add	r7, sp, #0
 327              	.LCFI16:
 328              		.cfi_def_cfa_register 7
 329 0006 7860     		str	r0, [r7, #4]
 330 0008 0B46     		mov	r3, r1
 331 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 137:../src/cc3000_spi.c **** 	SpiReadWriteStringInt(TRUE, data, size);
 332              		.loc 1 137 0
 333 000c 7B88     		ldrh	r3, [r7, #2]
 334 000e 4FF00100 		mov	r0, #1
 335 0012 7968     		ldr	r1, [r7, #4]
 336 0014 1A46     		mov	r2, r3
 337 0016 FFF7FEFF 		bl	SpiReadWriteStringInt
 138:../src/cc3000_spi.c **** }
 338              		.loc 1 138 0
 339 001a 07F10807 		add	r7, r7, #8
 340 001e BD46     		mov	sp, r7
 341 0020 80BD     		pop	{r7, pc}
 342              		.cfi_endproc
 343              	.LFE62:
 345 0022 00BF     		.section	.text.SpiWriteAsync,"ax",%progbits
 346              		.align	2
 347              		.global	SpiWriteAsync
 348              		.thumb
 349              		.thumb_func
 351              	SpiWriteAsync:
 352              	.LFB63:
 139:../src/cc3000_spi.c **** 
 140:../src/cc3000_spi.c **** /**
 141:../src/cc3000_spi.c ****  * @brief  This sends data over the SPI transport layer with
 142:../src/cc3000_spi.c ****  * @param  None
 143:../src/cc3000_spi.c ****  * @retval None
 144:../src/cc3000_spi.c ****  */
 145:../src/cc3000_spi.c **** void SpiWriteAsync(const unsigned char *data, unsigned short size)
 146:../src/cc3000_spi.c **** {
 353              		.loc 1 146 0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 8
 356              		@ frame_needed = 1, uses_anonymous_args = 0
 357 0000 80B5     		push	{r7, lr}
 358              	.LCFI17:
 359              		.cfi_def_cfa_offset 8
 360              		.cfi_offset 7, -8
 361              		.cfi_offset 14, -4
 362 0002 82B0     		sub	sp, sp, #8
 363              	.LCFI18:
 364              		.cfi_def_cfa_offset 16
 365 0004 00AF     		add	r7, sp, #0
 366              	.LCFI19:
 367              		.cfi_def_cfa_register 7
 368 0006 7860     		str	r0, [r7, #4]
 369 0008 0B46     		mov	r3, r1
 370 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 147:../src/cc3000_spi.c **** 	//
 148:../src/cc3000_spi.c **** 	// The DMA TX/RX channel must be disabled.
 149:../src/cc3000_spi.c **** 	//
 150:../src/cc3000_spi.c **** 	SpiReadWriteString(FALSE, data, size);
 371              		.loc 1 150 0
 372 000c 7B88     		ldrh	r3, [r7, #2]
 373 000e 4FF00000 		mov	r0, #0
 374 0012 7968     		ldr	r1, [r7, #4]
 375 0014 1A46     		mov	r2, r3
 376 0016 FFF7FEFF 		bl	SpiReadWriteString
 151:../src/cc3000_spi.c **** }
 377              		.loc 1 151 0
 378 001a 07F10807 		add	r7, r7, #8
 379 001e BD46     		mov	sp, r7
 380 0020 80BD     		pop	{r7, pc}
 381              		.cfi_endproc
 382              	.LFE63:
 384 0022 00BF     		.section	.text.SpiReadWriteStringInt,"ax",%progbits
 385              		.align	2
 386              		.global	SpiReadWriteStringInt
 387              		.thumb
 388              		.thumb_func
 390              	SpiReadWriteStringInt:
 391              	.LFB64:
 152:../src/cc3000_spi.c **** 
 153:../src/cc3000_spi.c **** /**
 154:../src/cc3000_spi.c ****  * @brief  This function TX and RX SPI data and configures interrupt generation
 155:../src/cc3000_spi.c ****  * 		at the end of the TX interrupt
 156:../src/cc3000_spi.c ****  * @param  ulTrueFlase True for a read or False for write
 157:../src/cc3000_spi.c ****  * @param  ptrData Pointer to data to be written
 158:../src/cc3000_spi.c ****  * @param  ulDataSize The size of the data to be written or read
 159:../src/cc3000_spi.c ****  * @retval None
 160:../src/cc3000_spi.c ****  */
 161:../src/cc3000_spi.c **** void SpiReadWriteStringInt(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize)
 162:../src/cc3000_spi.c **** {
 392              		.loc 1 162 0
 393              		.cfi_startproc
 394              		@ args = 0, pretend = 0, frame = 16
 395              		@ frame_needed = 1, uses_anonymous_args = 0
 396 0000 80B5     		push	{r7, lr}
 397              	.LCFI20:
 398              		.cfi_def_cfa_offset 8
 399              		.cfi_offset 7, -8
 400              		.cfi_offset 14, -4
 401 0002 84B0     		sub	sp, sp, #16
 402              	.LCFI21:
 403              		.cfi_def_cfa_offset 24
 404 0004 00AF     		add	r7, sp, #0
 405              	.LCFI22:
 406              		.cfi_def_cfa_register 7
 407 0006 F860     		str	r0, [r7, #12]
 408 0008 B960     		str	r1, [r7, #8]
 409 000a 7A60     		str	r2, [r7, #4]
 163:../src/cc3000_spi.c **** 	/* Delay for at lest 50 us at the start of every transfer */
 164:../src/cc3000_spi.c **** 	SysCtlDelay(FIFTY_US_DELAY);
 410              		.loc 1 164 0
 411 000c 40F20003 		movw	r3, #:lower16:SystemCoreClock
 412 0010 C0F20003 		movt	r3, #:upper16:SystemCoreClock
 413 0014 1A68     		ldr	r2, [r3, #0]
 414 0016 4DF68363 		movw	r3, #56963
 415 001a C4F21B33 		movt	r3, 17179
 416 001e A3FB0213 		umull	r1, r3, r3, r2
 417 0022 4FEA9343 		lsr	r3, r3, #18
 418 0026 4FF03202 		mov	r2, #50
 419 002a 02FB03F3 		mul	r3, r2, r3
 420 002e 4FEA9303 		lsr	r3, r3, #2
 421 0032 1846     		mov	r0, r3
 422 0034 FFF7FEFF 		bl	SysCtlDelay
 165:../src/cc3000_spi.c **** 
 166:../src/cc3000_spi.c **** 	/* Disable DMA Channels */
 167:../src/cc3000_spi.c **** 	CC3000_SPI_DMA_Channels(DISABLE);
 423              		.loc 1 167 0
 424 0038 4FF00000 		mov	r0, #0
 425 003c FFF7FEFF 		bl	CC3000_SPI_DMA_Channels
 168:../src/cc3000_spi.c **** 
 169:../src/cc3000_spi.c **** 	if (ulTrueFalse == TRUE)
 426              		.loc 1 169 0
 427 0040 FB68     		ldr	r3, [r7, #12]
 428 0042 012B     		cmp	r3, #1
 429 0044 13D1     		bne	.L13
 170:../src/cc3000_spi.c **** 	{
 171:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) ptrData, ulDataSize);
 430              		.loc 1 171 0
 431 0046 7B68     		ldr	r3, [r7, #4]
 432 0048 9BB2     		uxth	r3, r3
 433 004a 4FF00100 		mov	r0, #1
 434 004e B968     		ldr	r1, [r7, #8]
 435 0050 1A46     		mov	r2, r3
 436 0052 FFF7FEFF 		bl	CC3000_DMA_Config
 172:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) tSpiReadHeader, ulDataSize);
 437              		.loc 1 172 0
 438 0056 7B68     		ldr	r3, [r7, #4]
 439 0058 9BB2     		uxth	r3, r3
 440 005a 4FF00000 		mov	r0, #0
 441 005e 40F20001 		movw	r1, #:lower16:tSpiReadHeader
 442 0062 C0F20001 		movt	r1, #:upper16:tSpiReadHeader
 443 0066 1A46     		mov	r2, r3
 444 0068 FFF7FEFF 		bl	CC3000_DMA_Config
 445 006c 14E0     		b	.L14
 446              	.L13:
 173:../src/cc3000_spi.c **** 	}
 174:../src/cc3000_spi.c **** 	else
 175:../src/cc3000_spi.c **** 	{
 176:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) sSpiInformation.pRxPacket, ulDataSize);
 447              		.loc 1 176 0
 448 006e 40F20003 		movw	r3, #:lower16:sSpiInformation
 449 0072 C0F20003 		movt	r3, #:upper16:sSpiInformation
 450 0076 1A69     		ldr	r2, [r3, #16]
 451 0078 7B68     		ldr	r3, [r7, #4]
 452 007a 9BB2     		uxth	r3, r3
 453 007c 4FF00100 		mov	r0, #1
 454 0080 1146     		mov	r1, r2
 455 0082 1A46     		mov	r2, r3
 456 0084 FFF7FEFF 		bl	CC3000_DMA_Config
 177:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) ptrData, ulDataSize);
 457              		.loc 1 177 0
 458 0088 7B68     		ldr	r3, [r7, #4]
 459 008a 9BB2     		uxth	r3, r3
 460 008c 4FF00000 		mov	r0, #0
 461 0090 B968     		ldr	r1, [r7, #8]
 462 0092 1A46     		mov	r2, r3
 463 0094 FFF7FEFF 		bl	CC3000_DMA_Config
 464              	.L14:
 178:../src/cc3000_spi.c **** 	}
 179:../src/cc3000_spi.c **** 
 180:../src/cc3000_spi.c **** 	/* Enable DMA SPI Interrupt */
 181:../src/cc3000_spi.c **** 	DMA_ITConfig(CC3000_SPI_TX_DMA_CHANNEL, DMA_IT_TC, ENABLE);
 465              		.loc 1 181 0
 466 0098 4FF05800 		mov	r0, #88
 467 009c C4F20200 		movt	r0, 16386
 468 00a0 4FF00201 		mov	r1, #2
 469 00a4 4FF00102 		mov	r2, #1
 470 00a8 FFF7FEFF 		bl	DMA_ITConfig
 182:../src/cc3000_spi.c **** 
 183:../src/cc3000_spi.c **** 	/* Enable DMA Channels */
 184:../src/cc3000_spi.c **** 	CC3000_SPI_DMA_Channels(ENABLE);
 471              		.loc 1 184 0
 472 00ac 4FF00100 		mov	r0, #1
 473 00b0 FFF7FEFF 		bl	CC3000_SPI_DMA_Channels
 185:../src/cc3000_spi.c **** 
 186:../src/cc3000_spi.c **** 	/* Wait until DMA Transfer Completes */
 187:../src/cc3000_spi.c **** 	while(DMA_GetCurrDataCounter(CC3000_SPI_TX_DMA_CHANNEL))
 474              		.loc 1 187 0
 475 00b4 00BF     		nop
 476              	.L15:
 477              		.loc 1 187 0 is_stmt 0 discriminator 1
 478 00b6 4FF05800 		mov	r0, #88
 479 00ba C4F20200 		movt	r0, 16386
 480 00be FFF7FEFF 		bl	DMA_GetCurrDataCounter
 481 00c2 0346     		mov	r3, r0
 482 00c4 002B     		cmp	r3, #0
 483 00c6 F6D1     		bne	.L15
 188:../src/cc3000_spi.c **** 	{
 189:../src/cc3000_spi.c **** 	}
 190:../src/cc3000_spi.c **** 
 191:../src/cc3000_spi.c **** 	while(DMA_GetCurrDataCounter(CC3000_SPI_RX_DMA_CHANNEL))
 484              		.loc 1 191 0 is_stmt 1
 485 00c8 00BF     		nop
 486              	.L16:
 487              		.loc 1 191 0 is_stmt 0 discriminator 1
 488 00ca 4FF04400 		mov	r0, #68
 489 00ce C4F20200 		movt	r0, 16386
 490 00d2 FFF7FEFF 		bl	DMA_GetCurrDataCounter
 491 00d6 0346     		mov	r3, r0
 492 00d8 002B     		cmp	r3, #0
 493 00da F6D1     		bne	.L16
 192:../src/cc3000_spi.c **** 	{
 193:../src/cc3000_spi.c **** 	}
 194:../src/cc3000_spi.c **** 
 195:../src/cc3000_spi.c **** 	/* Loop until SPI busy */
 196:../src/cc3000_spi.c **** 	while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 494              		.loc 1 196 0 is_stmt 1
 495 00dc 00BF     		nop
 496              	.L17:
 497              		.loc 1 196 0 is_stmt 0 discriminator 1
 498 00de 4FF46050 		mov	r0, #14336
 499 00e2 C4F20000 		movt	r0, 16384
 500 00e6 4FF08001 		mov	r1, #128
 501 00ea FFF7FEFF 		bl	SPI_I2S_GetFlagStatus
 502 00ee 0346     		mov	r3, r0
 503 00f0 002B     		cmp	r3, #0
 504 00f2 F4D1     		bne	.L17
 197:../src/cc3000_spi.c **** 	{
 198:../src/cc3000_spi.c **** 	}
 199:../src/cc3000_spi.c **** }
 505              		.loc 1 199 0 is_stmt 1
 506 00f4 07F11007 		add	r7, r7, #16
 507 00f8 BD46     		mov	sp, r7
 508 00fa 80BD     		pop	{r7, pc}
 509              		.cfi_endproc
 510              	.LFE64:
 512              		.section	.text.SpiReadWriteString,"ax",%progbits
 513              		.align	2
 514              		.global	SpiReadWriteString
 515              		.thumb
 516              		.thumb_func
 518              	SpiReadWriteString:
 519              	.LFB65:
 200:../src/cc3000_spi.c **** 
 201:../src/cc3000_spi.c **** /**
 202:../src/cc3000_spi.c ****  * @brief  This function TX and RX SPI data with no interrupt at end of SPI TX
 203:../src/cc3000_spi.c ****  * @param  ulTrueFlase True for a read or False for write
 204:../src/cc3000_spi.c ****  * @param  ptrData Pointer to data to be written
 205:../src/cc3000_spi.c ****  * @param  ulDataSize The size of the data to be written or read
 206:../src/cc3000_spi.c ****  * @retval None
 207:../src/cc3000_spi.c ****  */
 208:../src/cc3000_spi.c **** void SpiReadWriteString(uint32_t ulTrueFalse, const uint8_t *ptrData, uint32_t ulDataSize)
 209:../src/cc3000_spi.c **** {
 520              		.loc 1 209 0
 521              		.cfi_startproc
 522              		@ args = 0, pretend = 0, frame = 16
 523              		@ frame_needed = 1, uses_anonymous_args = 0
 524 0000 80B5     		push	{r7, lr}
 525              	.LCFI23:
 526              		.cfi_def_cfa_offset 8
 527              		.cfi_offset 7, -8
 528              		.cfi_offset 14, -4
 529 0002 84B0     		sub	sp, sp, #16
 530              	.LCFI24:
 531              		.cfi_def_cfa_offset 24
 532 0004 00AF     		add	r7, sp, #0
 533              	.LCFI25:
 534              		.cfi_def_cfa_register 7
 535 0006 F860     		str	r0, [r7, #12]
 536 0008 B960     		str	r1, [r7, #8]
 537 000a 7A60     		str	r2, [r7, #4]
 210:../src/cc3000_spi.c **** 	SysCtlDelay(FIFTY_US_DELAY);
 538              		.loc 1 210 0
 539 000c 40F20003 		movw	r3, #:lower16:SystemCoreClock
 540 0010 C0F20003 		movt	r3, #:upper16:SystemCoreClock
 541 0014 1A68     		ldr	r2, [r3, #0]
 542 0016 4DF68363 		movw	r3, #56963
 543 001a C4F21B33 		movt	r3, 17179
 544 001e A3FB0213 		umull	r1, r3, r3, r2
 545 0022 4FEA9343 		lsr	r3, r3, #18
 546 0026 4FF03202 		mov	r2, #50
 547 002a 02FB03F3 		mul	r3, r2, r3
 548 002e 4FEA9303 		lsr	r3, r3, #2
 549 0032 1846     		mov	r0, r3
 550 0034 FFF7FEFF 		bl	SysCtlDelay
 211:../src/cc3000_spi.c **** 
 212:../src/cc3000_spi.c **** 	/* Disable DMA RX Channels */
 213:../src/cc3000_spi.c **** 	CC3000_SPI_DMA_Channels(DISABLE);
 551              		.loc 1 213 0
 552 0038 4FF00000 		mov	r0, #0
 553 003c FFF7FEFF 		bl	CC3000_SPI_DMA_Channels
 214:../src/cc3000_spi.c **** 
 215:../src/cc3000_spi.c **** 	/* Specify the DMA Read/Write buffer and size */
 216:../src/cc3000_spi.c **** 	if (ulTrueFalse == TRUE)
 554              		.loc 1 216 0
 555 0040 FB68     		ldr	r3, [r7, #12]
 556 0042 012B     		cmp	r3, #1
 557 0044 13D1     		bne	.L19
 217:../src/cc3000_spi.c **** 	{
 218:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) ptrData, ulDataSize);
 558              		.loc 1 218 0
 559 0046 7B68     		ldr	r3, [r7, #4]
 560 0048 9BB2     		uxth	r3, r3
 561 004a 4FF00100 		mov	r0, #1
 562 004e B968     		ldr	r1, [r7, #8]
 563 0050 1A46     		mov	r2, r3
 564 0052 FFF7FEFF 		bl	CC3000_DMA_Config
 219:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) tSpiReadHeader, ulDataSize);
 565              		.loc 1 219 0
 566 0056 7B68     		ldr	r3, [r7, #4]
 567 0058 9BB2     		uxth	r3, r3
 568 005a 4FF00000 		mov	r0, #0
 569 005e 40F20001 		movw	r1, #:lower16:tSpiReadHeader
 570 0062 C0F20001 		movt	r1, #:upper16:tSpiReadHeader
 571 0066 1A46     		mov	r2, r3
 572 0068 FFF7FEFF 		bl	CC3000_DMA_Config
 573 006c 14E0     		b	.L20
 574              	.L19:
 220:../src/cc3000_spi.c **** 	}
 221:../src/cc3000_spi.c **** 	else
 222:../src/cc3000_spi.c **** 	{
 223:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_RX, (uint8_t*) sSpiInformation.pRxPacket, ulDataSize);
 575              		.loc 1 223 0
 576 006e 40F20003 		movw	r3, #:lower16:sSpiInformation
 577 0072 C0F20003 		movt	r3, #:upper16:sSpiInformation
 578 0076 1A69     		ldr	r2, [r3, #16]
 579 0078 7B68     		ldr	r3, [r7, #4]
 580 007a 9BB2     		uxth	r3, r3
 581 007c 4FF00100 		mov	r0, #1
 582 0080 1146     		mov	r1, r2
 583 0082 1A46     		mov	r2, r3
 584 0084 FFF7FEFF 		bl	CC3000_DMA_Config
 224:../src/cc3000_spi.c **** 		CC3000_DMA_Config(CC3000_DMA_TX, (uint8_t*) ptrData, ulDataSize);
 585              		.loc 1 224 0
 586 0088 7B68     		ldr	r3, [r7, #4]
 587 008a 9BB2     		uxth	r3, r3
 588 008c 4FF00000 		mov	r0, #0
 589 0090 B968     		ldr	r1, [r7, #8]
 590 0092 1A46     		mov	r2, r3
 591 0094 FFF7FEFF 		bl	CC3000_DMA_Config
 592              	.L20:
 225:../src/cc3000_spi.c **** 	}
 226:../src/cc3000_spi.c **** 
 227:../src/cc3000_spi.c **** 	/* Enable DMA Channels */
 228:../src/cc3000_spi.c **** 	CC3000_SPI_DMA_Channels(ENABLE);
 593              		.loc 1 228 0
 594 0098 4FF00100 		mov	r0, #1
 595 009c FFF7FEFF 		bl	CC3000_SPI_DMA_Channels
 229:../src/cc3000_spi.c **** 
 230:../src/cc3000_spi.c **** 	/* Wait until DMA Transfer Completes */
 231:../src/cc3000_spi.c **** 	while(DMA_GetCurrDataCounter(CC3000_SPI_TX_DMA_CHANNEL))
 596              		.loc 1 231 0
 597 00a0 00BF     		nop
 598              	.L21:
 599              		.loc 1 231 0 is_stmt 0 discriminator 1
 600 00a2 4FF05800 		mov	r0, #88
 601 00a6 C4F20200 		movt	r0, 16386
 602 00aa FFF7FEFF 		bl	DMA_GetCurrDataCounter
 603 00ae 0346     		mov	r3, r0
 604 00b0 002B     		cmp	r3, #0
 605 00b2 F6D1     		bne	.L21
 232:../src/cc3000_spi.c **** 	{
 233:../src/cc3000_spi.c **** 	}
 234:../src/cc3000_spi.c **** 
 235:../src/cc3000_spi.c **** 	while(DMA_GetCurrDataCounter(CC3000_SPI_RX_DMA_CHANNEL))
 606              		.loc 1 235 0 is_stmt 1
 607 00b4 00BF     		nop
 608              	.L22:
 609              		.loc 1 235 0 is_stmt 0 discriminator 1
 610 00b6 4FF04400 		mov	r0, #68
 611 00ba C4F20200 		movt	r0, 16386
 612 00be FFF7FEFF 		bl	DMA_GetCurrDataCounter
 613 00c2 0346     		mov	r3, r0
 614 00c4 002B     		cmp	r3, #0
 615 00c6 F6D1     		bne	.L22
 236:../src/cc3000_spi.c **** 	{
 237:../src/cc3000_spi.c **** 	}
 238:../src/cc3000_spi.c **** 
 239:../src/cc3000_spi.c **** 	/* Loop until SPI busy */
 240:../src/cc3000_spi.c **** 	while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 616              		.loc 1 240 0 is_stmt 1
 617 00c8 00BF     		nop
 618              	.L23:
 619              		.loc 1 240 0 is_stmt 0 discriminator 1
 620 00ca 4FF46050 		mov	r0, #14336
 621 00ce C4F20000 		movt	r0, 16384
 622 00d2 4FF08001 		mov	r1, #128
 623 00d6 FFF7FEFF 		bl	SPI_I2S_GetFlagStatus
 624 00da 0346     		mov	r3, r0
 625 00dc 002B     		cmp	r3, #0
 626 00de F4D1     		bne	.L23
 241:../src/cc3000_spi.c **** 	{
 242:../src/cc3000_spi.c **** 	}
 243:../src/cc3000_spi.c **** }
 627              		.loc 1 243 0 is_stmt 1
 628 00e0 07F11007 		add	r7, r7, #16
 629 00e4 BD46     		mov	sp, r7
 630 00e6 80BD     		pop	{r7, pc}
 631              		.cfi_endproc
 632              	.LFE65:
 634              		.section	.text.SpiFirstWrite,"ax",%progbits
 635              		.align	2
 636              		.global	SpiFirstWrite
 637              		.thumb
 638              		.thumb_func
 640              	SpiFirstWrite:
 641              	.LFB66:
 244:../src/cc3000_spi.c **** 
 245:../src/cc3000_spi.c **** /**
 246:../src/cc3000_spi.c ****  * @brief  Sends header information to CC3000
 247:../src/cc3000_spi.c ****  * @param  None
 248:../src/cc3000_spi.c ****  * @retval None
 249:../src/cc3000_spi.c ****  */
 250:../src/cc3000_spi.c **** long SpiFirstWrite(unsigned char *ucBuf, unsigned short usLength)
 251:../src/cc3000_spi.c **** {
 642              		.loc 1 251 0
 643              		.cfi_startproc
 644              		@ args = 0, pretend = 0, frame = 8
 645              		@ frame_needed = 1, uses_anonymous_args = 0
 646 0000 80B5     		push	{r7, lr}
 647              	.LCFI26:
 648              		.cfi_def_cfa_offset 8
 649              		.cfi_offset 7, -8
 650              		.cfi_offset 14, -4
 651 0002 82B0     		sub	sp, sp, #8
 652              	.LCFI27:
 653              		.cfi_def_cfa_offset 16
 654 0004 00AF     		add	r7, sp, #0
 655              	.LCFI28:
 656              		.cfi_def_cfa_register 7
 657 0006 7860     		str	r0, [r7, #4]
 658 0008 0B46     		mov	r3, r1
 659 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 252:../src/cc3000_spi.c **** 	//
 253:../src/cc3000_spi.c **** 	// workaround for first transaction
 254:../src/cc3000_spi.c **** 	//
 255:../src/cc3000_spi.c **** 	ASSERT_CS();
 660              		.loc 1 255 0
 661 000c 4FF44060 		mov	r0, #3072
 662 0010 C4F20100 		movt	r0, 16385
 663 0014 4FF48051 		mov	r1, #4096
 664 0018 FFF7FEFF 		bl	GPIO_ResetBits
 256:../src/cc3000_spi.c **** 
 257:../src/cc3000_spi.c **** 	//SPI writes first 4 bytes of data
 258:../src/cc3000_spi.c **** 	SpiReadWriteString(FALSE, ucBuf, 4);
 665              		.loc 1 258 0
 666 001c 4FF00000 		mov	r0, #0
 667 0020 7968     		ldr	r1, [r7, #4]
 668 0022 4FF00402 		mov	r2, #4
 669 0026 FFF7FEFF 		bl	SpiReadWriteString
 259:../src/cc3000_spi.c **** 	//SPI writes next 4 bytes of data
 260:../src/cc3000_spi.c **** 	SpiReadWriteString(FALSE, ucBuf + 4, usLength - 4);
 670              		.loc 1 260 0
 671 002a 7B68     		ldr	r3, [r7, #4]
 672 002c 03F10402 		add	r2, r3, #4
 673 0030 7B88     		ldrh	r3, [r7, #2]
 674 0032 A3F10403 		sub	r3, r3, #4
 675 0036 4FF00000 		mov	r0, #0
 676 003a 1146     		mov	r1, r2
 677 003c 1A46     		mov	r2, r3
 678 003e FFF7FEFF 		bl	SpiReadWriteString
 261:../src/cc3000_spi.c **** 
 262:../src/cc3000_spi.c **** 	// From this point on - operate in a regular way
 263:../src/cc3000_spi.c **** 	sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 679              		.loc 1 263 0
 680 0042 40F20003 		movw	r3, #:lower16:sSpiInformation
 681 0046 C0F20003 		movt	r3, #:upper16:sSpiInformation
 682 004a 4FF00202 		mov	r2, #2
 683 004e 9A60     		str	r2, [r3, #8]
 264:../src/cc3000_spi.c **** 
 265:../src/cc3000_spi.c **** 	DEASSERT_CS();
 684              		.loc 1 265 0
 685 0050 4FF44060 		mov	r0, #3072
 686 0054 C4F20100 		movt	r0, 16385
 687 0058 4FF48051 		mov	r1, #4096
 688 005c FFF7FEFF 		bl	GPIO_SetBits
 266:../src/cc3000_spi.c **** 	return (0);
 689              		.loc 1 266 0
 690 0060 4FF00003 		mov	r3, #0
 267:../src/cc3000_spi.c **** }
 691              		.loc 1 267 0
 692 0064 1846     		mov	r0, r3
 693 0066 07F10807 		add	r7, r7, #8
 694 006a BD46     		mov	sp, r7
 695 006c 80BD     		pop	{r7, pc}
 696              		.cfi_endproc
 697              	.LFE66:
 699 006e 00BF     		.section	.text.SpiWrite,"ax",%progbits
 700              		.align	2
 701              		.global	SpiWrite
 702              		.thumb
 703              		.thumb_func
 705              	SpiWrite:
 706              	.LFB67:
 268:../src/cc3000_spi.c **** 
 269:../src/cc3000_spi.c **** /**
 270:../src/cc3000_spi.c ****  * @brief  Writes data over SPI  transport link to CC3000
 271:../src/cc3000_spi.c ****  * @param  pUserBuffer: pointer to data
 272:../src/cc3000_spi.c ****  * @param usLength: length of data that will be sent to CC3000
 273:../src/cc3000_spi.c ****  * @retval None
 274:../src/cc3000_spi.c ****  */
 275:../src/cc3000_spi.c **** long SpiWrite(unsigned char *pUserBuffer, unsigned short usLength)
 276:../src/cc3000_spi.c **** {
 707              		.loc 1 276 0
 708              		.cfi_startproc
 709              		@ args = 0, pretend = 0, frame = 16
 710              		@ frame_needed = 1, uses_anonymous_args = 0
 711 0000 80B5     		push	{r7, lr}
 712              	.LCFI29:
 713              		.cfi_def_cfa_offset 8
 714              		.cfi_offset 7, -8
 715              		.cfi_offset 14, -4
 716 0002 84B0     		sub	sp, sp, #16
 717              	.LCFI30:
 718              		.cfi_def_cfa_offset 24
 719 0004 00AF     		add	r7, sp, #0
 720              	.LCFI31:
 721              		.cfi_def_cfa_register 7
 722 0006 7860     		str	r0, [r7, #4]
 723 0008 0B46     		mov	r3, r1
 724 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 277:../src/cc3000_spi.c **** 	unsigned char ucPad = 0;
 725              		.loc 1 277 0
 726 000c 4FF00003 		mov	r3, #0
 727 0010 FB73     		strb	r3, [r7, #15]
 278:../src/cc3000_spi.c **** 	//
 279:../src/cc3000_spi.c **** 	// Figure out the total length of the packet in order to figure out if there is padding or not
 280:../src/cc3000_spi.c **** 	//
 281:../src/cc3000_spi.c **** 	if (!(usLength & 0x0001))
 728              		.loc 1 281 0
 729 0012 7B88     		ldrh	r3, [r7, #2]
 730 0014 03F00103 		and	r3, r3, #1
 731 0018 002B     		cmp	r3, #0
 732 001a 03D1     		bne	.L27
 282:../src/cc3000_spi.c **** 	{
 283:../src/cc3000_spi.c **** 		ucPad++;
 733              		.loc 1 283 0
 734 001c FB7B     		ldrb	r3, [r7, #15]
 735 001e 03F10103 		add	r3, r3, #1
 736 0022 FB73     		strb	r3, [r7, #15]
 737              	.L27:
 284:../src/cc3000_spi.c **** 	}
 285:../src/cc3000_spi.c **** 
 286:../src/cc3000_spi.c **** 	pUserBuffer[0] = WRITE;
 738              		.loc 1 286 0
 739 0024 7B68     		ldr	r3, [r7, #4]
 740 0026 4FF00102 		mov	r2, #1
 741 002a 1A70     		strb	r2, [r3, #0]
 287:../src/cc3000_spi.c **** 	pUserBuffer[1] = HI(usLength + ucPad);
 742              		.loc 1 287 0
 743 002c 7B68     		ldr	r3, [r7, #4]
 744 002e 03F10103 		add	r3, r3, #1
 745 0032 7988     		ldrh	r1, [r7, #2]
 746 0034 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 747 0036 8A18     		adds	r2, r1, r2
 748 0038 02F47F42 		and	r2, r2, #65280
 749 003c 4FEA2222 		asr	r2, r2, #8
 750 0040 D2B2     		uxtb	r2, r2
 751 0042 1A70     		strb	r2, [r3, #0]
 288:../src/cc3000_spi.c **** 	pUserBuffer[2] = LO(usLength + ucPad);
 752              		.loc 1 288 0
 753 0044 7B68     		ldr	r3, [r7, #4]
 754 0046 03F10203 		add	r3, r3, #2
 755 004a 7A88     		ldrh	r2, [r7, #2]	@ movhi
 756 004c D1B2     		uxtb	r1, r2
 757 004e FA7B     		ldrb	r2, [r7, #15]
 758 0050 8A18     		adds	r2, r1, r2
 759 0052 D2B2     		uxtb	r2, r2
 760 0054 1A70     		strb	r2, [r3, #0]
 289:../src/cc3000_spi.c **** 	pUserBuffer[3] = 0;
 761              		.loc 1 289 0
 762 0056 7B68     		ldr	r3, [r7, #4]
 763 0058 03F10303 		add	r3, r3, #3
 764 005c 4FF00002 		mov	r2, #0
 765 0060 1A70     		strb	r2, [r3, #0]
 290:../src/cc3000_spi.c **** 	pUserBuffer[4] = 0;
 766              		.loc 1 290 0
 767 0062 7B68     		ldr	r3, [r7, #4]
 768 0064 03F10403 		add	r3, r3, #4
 769 0068 4FF00002 		mov	r2, #0
 770 006c 1A70     		strb	r2, [r3, #0]
 291:../src/cc3000_spi.c **** 
 292:../src/cc3000_spi.c **** 	usLength += (SPI_HEADER_SIZE + ucPad);
 771              		.loc 1 292 0
 772 006e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 773 0070 9AB2     		uxth	r2, r3
 774 0072 7B88     		ldrh	r3, [r7, #2]	@ movhi
 775 0074 D318     		adds	r3, r2, r3
 776 0076 9BB2     		uxth	r3, r3
 777 0078 03F10503 		add	r3, r3, #5
 778 007c 7B80     		strh	r3, [r7, #2]	@ movhi
 293:../src/cc3000_spi.c **** 
 294:../src/cc3000_spi.c **** 	if (sSpiInformation.ulSpiState == eSPI_STATE_POWERUP)
 779              		.loc 1 294 0
 780 007e 40F20003 		movw	r3, #:lower16:sSpiInformation
 781 0082 C0F20003 		movt	r3, #:upper16:sSpiInformation
 782 0086 9B68     		ldr	r3, [r3, #8]
 783 0088 002B     		cmp	r3, #0
 784 008a 07D1     		bne	.L28
 295:../src/cc3000_spi.c **** 	{
 296:../src/cc3000_spi.c **** 		while (sSpiInformation.ulSpiState != eSPI_STATE_INITIALIZED)
 785              		.loc 1 296 0
 786 008c 00BF     		nop
 787              	.L29:
 788              		.loc 1 296 0 is_stmt 0 discriminator 1
 789 008e 40F20003 		movw	r3, #:lower16:sSpiInformation
 790 0092 C0F20003 		movt	r3, #:upper16:sSpiInformation
 791 0096 9B68     		ldr	r3, [r3, #8]
 792 0098 012B     		cmp	r3, #1
 793 009a F8D1     		bne	.L29
 794              	.L28:
 297:../src/cc3000_spi.c **** 		{
 298:../src/cc3000_spi.c **** 		}
 299:../src/cc3000_spi.c **** 	}
 300:../src/cc3000_spi.c **** 	if (sSpiInformation.ulSpiState == eSPI_STATE_INITIALIZED)
 795              		.loc 1 300 0 is_stmt 1
 796 009c 40F20003 		movw	r3, #:lower16:sSpiInformation
 797 00a0 C0F20003 		movt	r3, #:upper16:sSpiInformation
 798 00a4 9B68     		ldr	r3, [r3, #8]
 799 00a6 012B     		cmp	r3, #1
 800 00a8 0DD1     		bne	.L39
 301:../src/cc3000_spi.c **** 	{
 302:../src/cc3000_spi.c **** 
 303:../src/cc3000_spi.c **** 		//
 304:../src/cc3000_spi.c **** 		// This is time for first TX/RX transactions over SPI: the IRQ is down - so need to send read buf
 305:../src/cc3000_spi.c **** 		//
 306:../src/cc3000_spi.c **** 		SpiFirstWrite(pUserBuffer, usLength);
 801              		.loc 1 306 0
 802 00aa 7B88     		ldrh	r3, [r7, #2]
 803 00ac 7868     		ldr	r0, [r7, #4]
 804 00ae 1946     		mov	r1, r3
 805 00b0 FFF7FEFF 		bl	SpiFirstWrite
 307:../src/cc3000_spi.c **** 
 308:../src/cc3000_spi.c **** 		//
 309:../src/cc3000_spi.c **** 		// Due to the fact that we are currently implementing a blocking situation
 310:../src/cc3000_spi.c **** 		// here we will wait till end of transaction
 311:../src/cc3000_spi.c **** 		//
 312:../src/cc3000_spi.c **** 		while (eSPI_STATE_IDLE != sSpiInformation.ulSpiState)
 806              		.loc 1 312 0
 807 00b4 00BF     		nop
 808              	.L31:
 809              		.loc 1 312 0 is_stmt 0 discriminator 1
 810 00b6 40F20003 		movw	r3, #:lower16:sSpiInformation
 811 00ba C0F20003 		movt	r3, #:upper16:sSpiInformation
 812 00be 9B68     		ldr	r3, [r3, #8]
 813 00c0 022B     		cmp	r3, #2
 814 00c2 F8D1     		bne	.L31
 815              		.loc 1 312 0
 816 00c4 4AE0     		b	.L32
 817              	.L39:
 313:../src/cc3000_spi.c **** 		{
 314:../src/cc3000_spi.c **** 		}
 315:../src/cc3000_spi.c **** 	}
 316:../src/cc3000_spi.c **** 	else
 317:../src/cc3000_spi.c **** 	{
 318:../src/cc3000_spi.c **** 
 319:../src/cc3000_spi.c **** 		//
 320:../src/cc3000_spi.c **** 		// We need to prevent here race that can occur in case 2 back to back packets are sent to the
 321:../src/cc3000_spi.c **** 		// device, so the state will move to IDLE and once again to not IDLE due to IRQ
 322:../src/cc3000_spi.c **** 		//
 323:../src/cc3000_spi.c **** 		while (sSpiInformation.ulSpiState != eSPI_STATE_IDLE)
 818              		.loc 1 323 0 is_stmt 1
 819 00c6 00BF     		nop
 820              	.L33:
 821              		.loc 1 323 0 is_stmt 0 discriminator 1
 822 00c8 40F20003 		movw	r3, #:lower16:sSpiInformation
 823 00cc C0F20003 		movt	r3, #:upper16:sSpiInformation
 824 00d0 9B68     		ldr	r3, [r3, #8]
 825 00d2 022B     		cmp	r3, #2
 826 00d4 F8D1     		bne	.L33
 324:../src/cc3000_spi.c **** 		{
 325:../src/cc3000_spi.c **** 		}
 326:../src/cc3000_spi.c **** 
 327:../src/cc3000_spi.c **** 		/* Loop until SPI busy */
 328:../src/cc3000_spi.c **** 		while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 827              		.loc 1 328 0 is_stmt 1
 828 00d6 00BF     		nop
 829              	.L34:
 830              		.loc 1 328 0 is_stmt 0 discriminator 1
 831 00d8 4FF46050 		mov	r0, #14336
 832 00dc C4F20000 		movt	r0, 16384
 833 00e0 4FF08001 		mov	r1, #128
 834 00e4 FFF7FEFF 		bl	SPI_I2S_GetFlagStatus
 835 00e8 0346     		mov	r3, r0
 836 00ea 002B     		cmp	r3, #0
 837 00ec F4D1     		bne	.L34
 329:../src/cc3000_spi.c **** 		{
 330:../src/cc3000_spi.c **** 		}
 331:../src/cc3000_spi.c **** 
 332:../src/cc3000_spi.c **** 		//SysCtlDelay(9000000);
 333:../src/cc3000_spi.c **** 
 334:../src/cc3000_spi.c **** 		while (!tSLInformation.ReadWlanInterruptPin())
 838              		.loc 1 334 0 is_stmt 1
 839 00ee 00BF     		nop
 840              	.L35:
 841              		.loc 1 334 0 is_stmt 0 discriminator 1
 842 00f0 40F20003 		movw	r3, #:lower16:tSLInformation
 843 00f4 C0F20003 		movt	r3, #:upper16:tSLInformation
 844 00f8 DB69     		ldr	r3, [r3, #28]
 845 00fa 9847     		blx	r3
 846 00fc 0346     		mov	r3, r0
 847 00fe 002B     		cmp	r3, #0
 848 0100 F6D0     		beq	.L35
 335:../src/cc3000_spi.c **** 		{
 336:../src/cc3000_spi.c **** 		}
 337:../src/cc3000_spi.c **** 
 338:../src/cc3000_spi.c **** 		sSpiInformation.ulSpiState = eSPI_STATE_WRITE_IRQ;
 849              		.loc 1 338 0 is_stmt 1
 850 0102 40F20003 		movw	r3, #:lower16:sSpiInformation
 851 0106 C0F20003 		movt	r3, #:upper16:sSpiInformation
 852 010a 4FF00302 		mov	r2, #3
 853 010e 9A60     		str	r2, [r3, #8]
 339:../src/cc3000_spi.c **** 		sSpiInformation.pTxPacket = pUserBuffer;
 854              		.loc 1 339 0
 855 0110 40F20003 		movw	r3, #:lower16:sSpiInformation
 856 0114 C0F20003 		movt	r3, #:upper16:sSpiInformation
 857 0118 7A68     		ldr	r2, [r7, #4]
 858 011a DA60     		str	r2, [r3, #12]
 340:../src/cc3000_spi.c **** 		sSpiInformation.usTxPacketLength = usLength;
 859              		.loc 1 340 0
 860 011c 40F20003 		movw	r3, #:lower16:sSpiInformation
 861 0120 C0F20003 		movt	r3, #:upper16:sSpiInformation
 862 0124 7A88     		ldrh	r2, [r7, #2]	@ movhi
 863 0126 9A80     		strh	r2, [r3, #4]	@ movhi
 341:../src/cc3000_spi.c **** 
 342:../src/cc3000_spi.c **** 		//
 343:../src/cc3000_spi.c **** 		// Assert the CS line and wait till IRQ line is active and then initialize write operation
 344:../src/cc3000_spi.c **** 		//
 345:../src/cc3000_spi.c **** 		ASSERT_CS();
 864              		.loc 1 345 0
 865 0128 4FF44060 		mov	r0, #3072
 866 012c C4F20100 		movt	r0, 16385
 867 0130 4FF48051 		mov	r1, #4096
 868 0134 FFF7FEFF 		bl	GPIO_ResetBits
 346:../src/cc3000_spi.c **** 
 347:../src/cc3000_spi.c **** 		//SysCtlDelay(90000);
 348:../src/cc3000_spi.c **** 
 349:../src/cc3000_spi.c **** 		while (!tSLInformation.ReadWlanInterruptPin())
 869              		.loc 1 349 0
 870 0138 00BF     		nop
 871              	.L36:
 872              		.loc 1 349 0 is_stmt 0 discriminator 1
 873 013a 40F20003 		movw	r3, #:lower16:tSLInformation
 874 013e C0F20003 		movt	r3, #:upper16:tSLInformation
 875 0142 DB69     		ldr	r3, [r3, #28]
 876 0144 9847     		blx	r3
 877 0146 0346     		mov	r3, r0
 878 0148 002B     		cmp	r3, #0
 879 014a F6D0     		beq	.L36
 350:../src/cc3000_spi.c **** 		{
 351:../src/cc3000_spi.c **** 		}
 352:../src/cc3000_spi.c **** 
 353:../src/cc3000_spi.c **** 		//
 354:../src/cc3000_spi.c **** 		// Due to the fact that we are currently implementing a blocking situation
 355:../src/cc3000_spi.c **** 		// here we will wait till end of transaction
 356:../src/cc3000_spi.c **** 		//
 357:../src/cc3000_spi.c **** 		while (eSPI_STATE_IDLE != sSpiInformation.ulSpiState)
 880              		.loc 1 357 0 is_stmt 1
 881 014c 00BF     		nop
 882              	.L37:
 883              		.loc 1 357 0 is_stmt 0 discriminator 1
 884 014e 40F20003 		movw	r3, #:lower16:sSpiInformation
 885 0152 C0F20003 		movt	r3, #:upper16:sSpiInformation
 886 0156 9B68     		ldr	r3, [r3, #8]
 887 0158 022B     		cmp	r3, #2
 888 015a F8D1     		bne	.L37
 889              	.L32:
 358:../src/cc3000_spi.c **** 		{
 359:../src/cc3000_spi.c **** 		}
 360:../src/cc3000_spi.c **** 	}
 361:../src/cc3000_spi.c **** 	return (0);
 890              		.loc 1 361 0 is_stmt 1
 891 015c 4FF00003 		mov	r3, #0
 362:../src/cc3000_spi.c **** }
 892              		.loc 1 362 0
 893 0160 1846     		mov	r0, r3
 894 0162 07F11007 		add	r7, r7, #16
 895 0166 BD46     		mov	sp, r7
 896 0168 80BD     		pop	{r7, pc}
 897              		.cfi_endproc
 898              	.LFE67:
 900 016a 00BF     		.section	.text.SpiReadDataCont,"ax",%progbits
 901              		.align	2
 902              		.global	SpiReadDataCont
 903              		.thumb
 904              		.thumb_func
 906              	SpiReadDataCont:
 907              	.LFB68:
 363:../src/cc3000_spi.c **** 
 364:../src/cc3000_spi.c **** /**
 365:../src/cc3000_spi.c ****  * @brief  This function processes received SPI Header and in accordance with it
 366:../src/cc3000_spi.c ****  - continues reading the packet
 367:../src/cc3000_spi.c **** 
 368:../src/cc3000_spi.c ****  * @param  None
 369:../src/cc3000_spi.c ****  * @retval None
 370:../src/cc3000_spi.c ****  */
 371:../src/cc3000_spi.c **** long SpiReadDataCont(void)
 372:../src/cc3000_spi.c **** {
 908              		.loc 1 372 0
 909              		.cfi_startproc
 910              		@ args = 0, pretend = 0, frame = 16
 911              		@ frame_needed = 1, uses_anonymous_args = 0
 912 0000 80B5     		push	{r7, lr}
 913              	.LCFI32:
 914              		.cfi_def_cfa_offset 8
 915              		.cfi_offset 7, -8
 916              		.cfi_offset 14, -4
 917 0002 84B0     		sub	sp, sp, #16
 918              	.LCFI33:
 919              		.cfi_def_cfa_offset 24
 920 0004 00AF     		add	r7, sp, #0
 921              	.LCFI34:
 922              		.cfi_def_cfa_register 7
 373:../src/cc3000_spi.c **** 	long data_to_recv;
 374:../src/cc3000_spi.c **** 
 375:../src/cc3000_spi.c **** 	unsigned char *evnt_buff, type;
 376:../src/cc3000_spi.c **** 
 377:../src/cc3000_spi.c **** 	//
 378:../src/cc3000_spi.c **** 	//determine what type of packet we have
 379:../src/cc3000_spi.c **** 	//
 380:../src/cc3000_spi.c **** 	evnt_buff = sSpiInformation.pRxPacket;
 923              		.loc 1 380 0
 924 0006 40F20003 		movw	r3, #:lower16:sSpiInformation
 925 000a C0F20003 		movt	r3, #:upper16:sSpiInformation
 926 000e 1B69     		ldr	r3, [r3, #16]
 927 0010 BB60     		str	r3, [r7, #8]
 381:../src/cc3000_spi.c **** 	data_to_recv = 0;
 928              		.loc 1 381 0
 929 0012 4FF00003 		mov	r3, #0
 930 0016 FB60     		str	r3, [r7, #12]
 382:../src/cc3000_spi.c **** 	STREAM_TO_UINT8((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_PACKET_TYPE_OFFSET, type);
 931              		.loc 1 382 0
 932 0018 BB68     		ldr	r3, [r7, #8]
 933 001a 03F10503 		add	r3, r3, #5
 934 001e 1B78     		ldrb	r3, [r3, #0]
 935 0020 FB71     		strb	r3, [r7, #7]
 383:../src/cc3000_spi.c **** 
 384:../src/cc3000_spi.c **** 	switch (type)
 936              		.loc 1 384 0
 937 0022 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 938 0024 022B     		cmp	r3, #2
 939 0026 02D0     		beq	.L42
 940 0028 042B     		cmp	r3, #4
 941 002a 3FD0     		beq	.L43
 942 002c 64E0     		b	.L41
 943              	.L42:
 385:../src/cc3000_spi.c **** 	{
 386:../src/cc3000_spi.c **** 		case HCI_TYPE_DATA:
 387:../src/cc3000_spi.c **** 		{
 388:../src/cc3000_spi.c **** 			STREAM_TO_UINT16((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_DATA_LENGTH_OFFSET, data_to_recv);
 944              		.loc 1 388 0
 945 002e BB68     		ldr	r3, [r7, #8]
 946 0030 03F10503 		add	r3, r3, #5
 947 0034 1846     		mov	r0, r3
 948 0036 4FF00301 		mov	r1, #3
 949 003a FFF7FEFF 		bl	STREAM_TO_UINT16_f
 950 003e 0346     		mov	r3, r0
 951 0040 FB60     		str	r3, [r7, #12]
 389:../src/cc3000_spi.c **** 
 390:../src/cc3000_spi.c **** 			if (data_to_recv >= SPI_WINDOW_SIZE)
 952              		.loc 1 390 0
 953 0042 FA68     		ldr	r2, [r7, #12]
 954 0044 40F2FF33 		movw	r3, #1023
 955 0048 9A42     		cmp	r2, r3
 956 004a 12DD     		ble	.L44
 391:../src/cc3000_spi.c **** 			{
 392:../src/cc3000_spi.c **** 				data_to_recv = eSPI_STATE_READ_FIRST_PORTION;
 957              		.loc 1 392 0
 958 004c 4FF00703 		mov	r3, #7
 959 0050 FB60     		str	r3, [r7, #12]
 393:../src/cc3000_spi.c **** 				SpiReadData(evnt_buff + 10, SPI_WINDOW_SIZE);
 960              		.loc 1 393 0
 961 0052 BB68     		ldr	r3, [r7, #8]
 962 0054 03F10A03 		add	r3, r3, #10
 963 0058 1846     		mov	r0, r3
 964 005a 4FF48061 		mov	r1, #1024
 965 005e FFF7FEFF 		bl	SpiReadData
 394:../src/cc3000_spi.c **** 				sSpiInformation.ulSpiState = eSPI_STATE_READ_FIRST_PORTION;
 966              		.loc 1 394 0
 967 0062 40F20003 		movw	r3, #:lower16:sSpiInformation
 968 0066 C0F20003 		movt	r3, #:upper16:sSpiInformation
 969 006a 4FF00702 		mov	r2, #7
 970 006e 9A60     		str	r2, [r3, #8]
 395:../src/cc3000_spi.c **** 			}
 396:../src/cc3000_spi.c **** 			else
 397:../src/cc3000_spi.c **** 			{
 398:../src/cc3000_spi.c **** 				//
 399:../src/cc3000_spi.c **** 				// We need to read the rest of data..
 400:../src/cc3000_spi.c **** 				//
 401:../src/cc3000_spi.c **** 				if (!((HEADERS_SIZE_EVNT + data_to_recv) & 1))
 402:../src/cc3000_spi.c **** 				{
 403:../src/cc3000_spi.c **** 					data_to_recv++;
 404:../src/cc3000_spi.c **** 				}
 405:../src/cc3000_spi.c **** 
 406:../src/cc3000_spi.c **** 				if (data_to_recv)
 407:../src/cc3000_spi.c **** 				{
 408:../src/cc3000_spi.c **** 					SpiReadData(evnt_buff + 10, data_to_recv);
 409:../src/cc3000_spi.c **** 				}
 410:../src/cc3000_spi.c **** 
 411:../src/cc3000_spi.c **** 				sSpiInformation.ulSpiState = eSPI_STATE_READ_EOT;
 412:../src/cc3000_spi.c **** 			}
 413:../src/cc3000_spi.c **** 			break;
 971              		.loc 1 413 0
 972 0070 42E0     		b	.L41
 973              	.L44:
 401:../src/cc3000_spi.c **** 				if (!((HEADERS_SIZE_EVNT + data_to_recv) & 1))
 974              		.loc 1 401 0
 975 0072 FB68     		ldr	r3, [r7, #12]
 976 0074 03F00103 		and	r3, r3, #1
 977 0078 002B     		cmp	r3, #0
 978 007a 03D1     		bne	.L46
 403:../src/cc3000_spi.c **** 					data_to_recv++;
 979              		.loc 1 403 0
 980 007c FB68     		ldr	r3, [r7, #12]
 981 007e 03F10103 		add	r3, r3, #1
 982 0082 FB60     		str	r3, [r7, #12]
 983              	.L46:
 406:../src/cc3000_spi.c **** 				if (data_to_recv)
 984              		.loc 1 406 0
 985 0084 FB68     		ldr	r3, [r7, #12]
 986 0086 002B     		cmp	r3, #0
 987 0088 08D0     		beq	.L47
 408:../src/cc3000_spi.c **** 					SpiReadData(evnt_buff + 10, data_to_recv);
 988              		.loc 1 408 0
 989 008a BB68     		ldr	r3, [r7, #8]
 990 008c 03F10A02 		add	r2, r3, #10
 991 0090 FB68     		ldr	r3, [r7, #12]
 992 0092 9BB2     		uxth	r3, r3
 993 0094 1046     		mov	r0, r2
 994 0096 1946     		mov	r1, r3
 995 0098 FFF7FEFF 		bl	SpiReadData
 996              	.L47:
 411:../src/cc3000_spi.c **** 				sSpiInformation.ulSpiState = eSPI_STATE_READ_EOT;
 997              		.loc 1 411 0
 998 009c 40F20003 		movw	r3, #:lower16:sSpiInformation
 999 00a0 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1000 00a4 4FF00802 		mov	r2, #8
 1001 00a8 9A60     		str	r2, [r3, #8]
 1002              		.loc 1 413 0
 1003 00aa 25E0     		b	.L41
 1004              	.L43:
 414:../src/cc3000_spi.c **** 		}
 415:../src/cc3000_spi.c **** 		case HCI_TYPE_EVNT:
 416:../src/cc3000_spi.c **** 		{
 417:../src/cc3000_spi.c **** 			//
 418:../src/cc3000_spi.c **** 			// Calculate the rest length of the data
 419:../src/cc3000_spi.c **** 			//
 420:../src/cc3000_spi.c **** 			STREAM_TO_UINT8((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_EVENT_LENGTH_OFFSET, data_to_recv);
 1005              		.loc 1 420 0
 1006 00ac BB68     		ldr	r3, [r7, #8]
 1007 00ae 03F10803 		add	r3, r3, #8
 1008 00b2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1009 00b4 FB60     		str	r3, [r7, #12]
 421:../src/cc3000_spi.c **** 			data_to_recv -= 1;
 1010              		.loc 1 421 0
 1011 00b6 FB68     		ldr	r3, [r7, #12]
 1012 00b8 03F1FF33 		add	r3, r3, #-1
 1013 00bc FB60     		str	r3, [r7, #12]
 422:../src/cc3000_spi.c **** 
 423:../src/cc3000_spi.c **** 			//
 424:../src/cc3000_spi.c **** 			// Add padding byte if needed
 425:../src/cc3000_spi.c **** 			//
 426:../src/cc3000_spi.c **** 			if ((HEADERS_SIZE_EVNT + data_to_recv) & 1)
 1014              		.loc 1 426 0
 1015 00be FB68     		ldr	r3, [r7, #12]
 1016 00c0 03F00103 		and	r3, r3, #1
 1017 00c4 002B     		cmp	r3, #0
 1018 00c6 03D0     		beq	.L48
 427:../src/cc3000_spi.c **** 			{
 428:../src/cc3000_spi.c **** 
 429:../src/cc3000_spi.c **** 				data_to_recv++;
 1019              		.loc 1 429 0
 1020 00c8 FB68     		ldr	r3, [r7, #12]
 1021 00ca 03F10103 		add	r3, r3, #1
 1022 00ce FB60     		str	r3, [r7, #12]
 1023              	.L48:
 430:../src/cc3000_spi.c **** 			}
 431:../src/cc3000_spi.c **** 
 432:../src/cc3000_spi.c **** 			if (data_to_recv)
 1024              		.loc 1 432 0
 1025 00d0 FB68     		ldr	r3, [r7, #12]
 1026 00d2 002B     		cmp	r3, #0
 1027 00d4 08D0     		beq	.L49
 433:../src/cc3000_spi.c **** 			{
 434:../src/cc3000_spi.c **** 				SpiReadData(evnt_buff + 10, data_to_recv);
 1028              		.loc 1 434 0
 1029 00d6 BB68     		ldr	r3, [r7, #8]
 1030 00d8 03F10A02 		add	r2, r3, #10
 1031 00dc FB68     		ldr	r3, [r7, #12]
 1032 00de 9BB2     		uxth	r3, r3
 1033 00e0 1046     		mov	r0, r2
 1034 00e2 1946     		mov	r1, r3
 1035 00e4 FFF7FEFF 		bl	SpiReadData
 1036              	.L49:
 435:../src/cc3000_spi.c **** 			}
 436:../src/cc3000_spi.c **** 
 437:../src/cc3000_spi.c **** 			sSpiInformation.ulSpiState = eSPI_STATE_READ_EOT;
 1037              		.loc 1 437 0
 1038 00e8 40F20003 		movw	r3, #:lower16:sSpiInformation
 1039 00ec C0F20003 		movt	r3, #:upper16:sSpiInformation
 1040 00f0 4FF00802 		mov	r2, #8
 1041 00f4 9A60     		str	r2, [r3, #8]
 438:../src/cc3000_spi.c **** 			break;
 1042              		.loc 1 438 0
 1043 00f6 00BF     		nop
 1044              	.L41:
 439:../src/cc3000_spi.c **** 		}
 440:../src/cc3000_spi.c **** 	}
 441:../src/cc3000_spi.c **** 
 442:../src/cc3000_spi.c **** 	return (data_to_recv);
 1045              		.loc 1 442 0
 1046 00f8 FB68     		ldr	r3, [r7, #12]
 443:../src/cc3000_spi.c **** }
 1047              		.loc 1 443 0
 1048 00fa 1846     		mov	r0, r3
 1049 00fc 07F11007 		add	r7, r7, #16
 1050 0100 BD46     		mov	sp, r7
 1051 0102 80BD     		pop	{r7, pc}
 1052              		.cfi_endproc
 1053              	.LFE68:
 1055              		.section	.text.SpiReadHeader,"ax",%progbits
 1056              		.align	2
 1057              		.global	SpiReadHeader
 1058              		.thumb
 1059              		.thumb_func
 1061              	SpiReadHeader:
 1062              	.LFB69:
 444:../src/cc3000_spi.c **** 
 445:../src/cc3000_spi.c **** /**
 446:../src/cc3000_spi.c ****  * @brief  This function enter point for read flow: first we read minimal
 447:../src/cc3000_spi.c ****  5 SPI header bytes and 5 Event Data bytes
 448:../src/cc3000_spi.c **** 
 449:../src/cc3000_spi.c ****  * @param  None
 450:../src/cc3000_spi.c ****  * @retval None
 451:../src/cc3000_spi.c ****  */
 452:../src/cc3000_spi.c **** void SpiReadHeader(void)
 453:../src/cc3000_spi.c **** {
 1063              		.loc 1 453 0
 1064              		.cfi_startproc
 1065              		@ args = 0, pretend = 0, frame = 0
 1066              		@ frame_needed = 1, uses_anonymous_args = 0
 1067 0000 80B5     		push	{r7, lr}
 1068              	.LCFI35:
 1069              		.cfi_def_cfa_offset 8
 1070              		.cfi_offset 7, -8
 1071              		.cfi_offset 14, -4
 1072 0002 00AF     		add	r7, sp, #0
 1073              	.LCFI36:
 1074              		.cfi_def_cfa_register 7
 454:../src/cc3000_spi.c **** 	SpiReadWriteStringInt(TRUE, sSpiInformation.pRxPacket, 10);
 1075              		.loc 1 454 0
 1076 0004 40F20003 		movw	r3, #:lower16:sSpiInformation
 1077 0008 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1078 000c 1B69     		ldr	r3, [r3, #16]
 1079 000e 4FF00100 		mov	r0, #1
 1080 0012 1946     		mov	r1, r3
 1081 0014 4FF00A02 		mov	r2, #10
 1082 0018 FFF7FEFF 		bl	SpiReadWriteStringInt
 455:../src/cc3000_spi.c **** }
 1083              		.loc 1 455 0
 1084 001c 80BD     		pop	{r7, pc}
 1085              		.cfi_endproc
 1086              	.LFE69:
 1088 001e 00BF     		.section	.text.SpiContReadOperation,"ax",%progbits
 1089              		.align	2
 1090              		.global	SpiContReadOperation
 1091              		.thumb
 1092              		.thumb_func
 1094              	SpiContReadOperation:
 1095              	.LFB70:
 456:../src/cc3000_spi.c **** 
 457:../src/cc3000_spi.c **** /**
 458:../src/cc3000_spi.c ****  * @brief  Determine if all data was read if so end the data exchange
 459:../src/cc3000_spi.c ****  * @param  None
 460:../src/cc3000_spi.c ****  * @retval None
 461:../src/cc3000_spi.c ****  */
 462:../src/cc3000_spi.c **** void SpiContReadOperation(void)
 463:../src/cc3000_spi.c **** {
 1096              		.loc 1 463 0
 1097              		.cfi_startproc
 1098              		@ args = 0, pretend = 0, frame = 0
 1099              		@ frame_needed = 1, uses_anonymous_args = 0
 1100 0000 80B5     		push	{r7, lr}
 1101              	.LCFI37:
 1102              		.cfi_def_cfa_offset 8
 1103              		.cfi_offset 7, -8
 1104              		.cfi_offset 14, -4
 1105 0002 00AF     		add	r7, sp, #0
 1106              	.LCFI38:
 1107              		.cfi_def_cfa_register 7
 464:../src/cc3000_spi.c **** 	//
 465:../src/cc3000_spi.c **** 	// The header was read - continue with  the payload read
 466:../src/cc3000_spi.c **** 	//
 467:../src/cc3000_spi.c **** 	if (!SpiReadDataCont())
 1108              		.loc 1 467 0
 1109 0004 FFF7FEFF 		bl	SpiReadDataCont
 1110 0008 0346     		mov	r3, r0
 1111 000a 002B     		cmp	r3, #0
 1112 000c 01D1     		bne	.L52
 468:../src/cc3000_spi.c **** 	{
 469:../src/cc3000_spi.c **** 		//
 470:../src/cc3000_spi.c **** 		// All the data was read - finalize handling by switching to teh task
 471:../src/cc3000_spi.c **** 		//	and calling from task Event Handler
 472:../src/cc3000_spi.c **** 		//
 473:../src/cc3000_spi.c **** 		SpiTriggerRxProcessing();
 1113              		.loc 1 473 0
 1114 000e FFF7FEFF 		bl	SpiTriggerRxProcessing
 1115              	.L52:
 474:../src/cc3000_spi.c **** 	}
 475:../src/cc3000_spi.c **** }
 1116              		.loc 1 475 0
 1117 0012 80BD     		pop	{r7, pc}
 1118              		.cfi_endproc
 1119              	.LFE70:
 1121              		.section	.text.SPI_DMA_IntHandler,"ax",%progbits
 1122              		.align	2
 1123              		.global	SPI_DMA_IntHandler
 1124              		.thumb
 1125              		.thumb_func
 1127              	SPI_DMA_IntHandler:
 1128              	.LFB71:
 476:../src/cc3000_spi.c **** 
 477:../src/cc3000_spi.c **** /**
 478:../src/cc3000_spi.c ****  * @brief  The handler for Interrupt that is generated on SPI at the end of DMA
 479:../src/cc3000_spi.c ****  transfer.
 480:../src/cc3000_spi.c ****  * @param  None
 481:../src/cc3000_spi.c ****  * @retval None
 482:../src/cc3000_spi.c ****  */
 483:../src/cc3000_spi.c **** void SPI_DMA_IntHandler(void)
 484:../src/cc3000_spi.c **** {
 1129              		.loc 1 484 0
 1130              		.cfi_startproc
 1131              		@ args = 0, pretend = 0, frame = 16
 1132              		@ frame_needed = 1, uses_anonymous_args = 0
 1133 0000 80B5     		push	{r7, lr}
 1134              	.LCFI39:
 1135              		.cfi_def_cfa_offset 8
 1136              		.cfi_offset 7, -8
 1137              		.cfi_offset 14, -4
 1138 0002 84B0     		sub	sp, sp, #16
 1139              	.LCFI40:
 1140              		.cfi_def_cfa_offset 24
 1141 0004 00AF     		add	r7, sp, #0
 1142              	.LCFI41:
 1143              		.cfi_def_cfa_register 7
 485:../src/cc3000_spi.c **** 	unsigned long ucTxFinished, ucRxFinished;
 486:../src/cc3000_spi.c **** 	unsigned short data_to_recv;
 487:../src/cc3000_spi.c **** 	unsigned char *evnt_buff;
 488:../src/cc3000_spi.c **** 
 489:../src/cc3000_spi.c **** 	evnt_buff = sSpiInformation.pRxPacket;
 1144              		.loc 1 489 0
 1145 0006 40F20003 		movw	r3, #:lower16:sSpiInformation
 1146 000a C0F20003 		movt	r3, #:upper16:sSpiInformation
 1147 000e 1B69     		ldr	r3, [r3, #16]
 1148 0010 BB60     		str	r3, [r7, #8]
 490:../src/cc3000_spi.c **** 	data_to_recv = 0;
 1149              		.loc 1 490 0
 1150 0012 4FF00003 		mov	r3, #0
 1151 0016 FB81     		strh	r3, [r7, #14]	@ movhi
 491:../src/cc3000_spi.c **** 
 492:../src/cc3000_spi.c **** 	ucTxFinished = DMA_GetFlagStatus(CC3000_SPI_TX_DMA_TCFLAG );
 1152              		.loc 1 492 0
 1153 0018 4FF40030 		mov	r0, #131072
 1154 001c FFF7FEFF 		bl	DMA_GetFlagStatus
 1155 0020 0346     		mov	r3, r0
 1156 0022 7B60     		str	r3, [r7, #4]
 493:../src/cc3000_spi.c **** 	ucRxFinished = DMA_GetFlagStatus(CC3000_SPI_RX_DMA_TCFLAG );
 1157              		.loc 1 493 0
 1158 0024 4FF40050 		mov	r0, #8192
 1159 0028 FFF7FEFF 		bl	DMA_GetFlagStatus
 1160 002c 0346     		mov	r3, r0
 1161 002e 3B60     		str	r3, [r7, #0]
 494:../src/cc3000_spi.c **** 
 495:../src/cc3000_spi.c **** 	if (sSpiInformation.ulSpiState == eSPI_STATE_READ_IRQ)
 1162              		.loc 1 495 0
 1163 0030 40F20003 		movw	r3, #:lower16:sSpiInformation
 1164 0034 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1165 0038 9B68     		ldr	r3, [r3, #8]
 1166 003a 062B     		cmp	r3, #6
 1167 003c 0ED1     		bne	.L55
 496:../src/cc3000_spi.c **** 	{
 497:../src/cc3000_spi.c **** 		//
 498:../src/cc3000_spi.c **** 		// If one of DMA's still did not finished its operation - we need to stay
 499:../src/cc3000_spi.c **** 		// and wait till it will finish
 500:../src/cc3000_spi.c **** 		//
 501:../src/cc3000_spi.c **** 		if (ucTxFinished && ucRxFinished)
 1168              		.loc 1 501 0
 1169 003e 7B68     		ldr	r3, [r7, #4]
 1170 0040 002B     		cmp	r3, #0
 1171 0042 00F0A480 		beq	.L54
 1172              		.loc 1 501 0 is_stmt 0 discriminator 1
 1173 0046 3B68     		ldr	r3, [r7, #0]
 1174 0048 002B     		cmp	r3, #0
 1175 004a 00F0A080 		beq	.L54
 502:../src/cc3000_spi.c **** 		{
 503:../src/cc3000_spi.c **** 			/* Clear SPI_DMA Interrupt Pending Flags */
 504:../src/cc3000_spi.c **** 			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 1176              		.loc 1 504 0 is_stmt 1
 1177 004e 4FF40830 		mov	r0, #139264
 1178 0052 FFF7FEFF 		bl	DMA_ClearFlag
 505:../src/cc3000_spi.c **** 
 506:../src/cc3000_spi.c **** 			SpiContReadOperation();
 1179              		.loc 1 506 0
 1180 0056 FFF7FEFF 		bl	SpiContReadOperation
 1181 005a 98E0     		b	.L54
 1182              	.L55:
 507:../src/cc3000_spi.c **** 		}
 508:../src/cc3000_spi.c **** 	}
 509:../src/cc3000_spi.c **** 	else if (sSpiInformation.ulSpiState == eSPI_STATE_READ_FIRST_PORTION)
 1183              		.loc 1 509 0
 1184 005c 40F20003 		movw	r3, #:lower16:sSpiInformation
 1185 0060 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1186 0064 9B68     		ldr	r3, [r3, #8]
 1187 0066 072B     		cmp	r3, #7
 1188 0068 32D1     		bne	.L57
 510:../src/cc3000_spi.c **** 	{
 511:../src/cc3000_spi.c **** 		if (ucRxFinished)
 1189              		.loc 1 511 0
 1190 006a 3B68     		ldr	r3, [r7, #0]
 1191 006c 002B     		cmp	r3, #0
 1192 006e 00F08E80 		beq	.L54
 512:../src/cc3000_spi.c **** 		{
 513:../src/cc3000_spi.c **** 			/* Clear SPI_DMA Interrupt Pending Flags */
 514:../src/cc3000_spi.c **** 			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 1193              		.loc 1 514 0
 1194 0072 4FF40830 		mov	r0, #139264
 1195 0076 FFF7FEFF 		bl	DMA_ClearFlag
 515:../src/cc3000_spi.c **** 
 516:../src/cc3000_spi.c **** 			STREAM_TO_UINT16((char *)(evnt_buff + SPI_HEADER_SIZE), HCI_DATA_LENGTH_OFFSET, data_to_recv);
 1196              		.loc 1 516 0
 1197 007a BB68     		ldr	r3, [r7, #8]
 1198 007c 03F10503 		add	r3, r3, #5
 1199 0080 1846     		mov	r0, r3
 1200 0082 4FF00301 		mov	r1, #3
 1201 0086 FFF7FEFF 		bl	STREAM_TO_UINT16_f
 1202 008a 0346     		mov	r3, r0
 1203 008c FB81     		strh	r3, [r7, #14]	@ movhi
 517:../src/cc3000_spi.c **** 
 518:../src/cc3000_spi.c **** 			//
 519:../src/cc3000_spi.c **** 			// Read the last portion of data
 520:../src/cc3000_spi.c **** 			//
 521:../src/cc3000_spi.c **** 			//
 522:../src/cc3000_spi.c **** 			// We need to read the rest of data..
 523:../src/cc3000_spi.c **** 			//
 524:../src/cc3000_spi.c **** 			data_to_recv -= SPI_WINDOW_SIZE;
 1204              		.loc 1 524 0
 1205 008e FB89     		ldrh	r3, [r7, #14]	@ movhi
 1206 0090 A3F58063 		sub	r3, r3, #1024
 1207 0094 FB81     		strh	r3, [r7, #14]	@ movhi
 525:../src/cc3000_spi.c **** 
 526:../src/cc3000_spi.c **** 			if (!((HEADERS_SIZE_EVNT + data_to_recv) & 1))
 1208              		.loc 1 526 0
 1209 0096 FB89     		ldrh	r3, [r7, #14]
 1210 0098 03F00103 		and	r3, r3, #1
 1211 009c 002B     		cmp	r3, #0
 1212 009e 03D1     		bne	.L58
 527:../src/cc3000_spi.c **** 			{
 528:../src/cc3000_spi.c **** 				data_to_recv++;
 1213              		.loc 1 528 0
 1214 00a0 FB89     		ldrh	r3, [r7, #14]	@ movhi
 1215 00a2 03F10103 		add	r3, r3, #1
 1216 00a6 FB81     		strh	r3, [r7, #14]	@ movhi
 1217              	.L58:
 529:../src/cc3000_spi.c **** 			}
 530:../src/cc3000_spi.c **** 
 531:../src/cc3000_spi.c **** 			SpiReadData(sSpiInformation.pRxPacket + 10 + SPI_WINDOW_SIZE, data_to_recv);
 1218              		.loc 1 531 0
 1219 00a8 40F20003 		movw	r3, #:lower16:sSpiInformation
 1220 00ac C0F20003 		movt	r3, #:upper16:sSpiInformation
 1221 00b0 1B69     		ldr	r3, [r3, #16]
 1222 00b2 03F20A42 		addw	r2, r3, #1034
 1223 00b6 FB89     		ldrh	r3, [r7, #14]
 1224 00b8 1046     		mov	r0, r2
 1225 00ba 1946     		mov	r1, r3
 1226 00bc FFF7FEFF 		bl	SpiReadData
 532:../src/cc3000_spi.c **** 
 533:../src/cc3000_spi.c **** 			sSpiInformation.ulSpiState = eSPI_STATE_READ_EOT;
 1227              		.loc 1 533 0
 1228 00c0 40F20003 		movw	r3, #:lower16:sSpiInformation
 1229 00c4 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1230 00c8 4FF00802 		mov	r2, #8
 1231 00cc 9A60     		str	r2, [r3, #8]
 1232 00ce 5EE0     		b	.L54
 1233              	.L57:
 534:../src/cc3000_spi.c **** 		}
 535:../src/cc3000_spi.c **** 	}
 536:../src/cc3000_spi.c **** 	else if (sSpiInformation.ulSpiState == eSPI_STATE_READ_EOT)
 1234              		.loc 1 536 0
 1235 00d0 40F20003 		movw	r3, #:lower16:sSpiInformation
 1236 00d4 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1237 00d8 9B68     		ldr	r3, [r3, #8]
 1238 00da 082B     		cmp	r3, #8
 1239 00dc 09D1     		bne	.L59
 537:../src/cc3000_spi.c **** 	{
 538:../src/cc3000_spi.c **** 		//
 539:../src/cc3000_spi.c **** 		// All the data was read - finalize handling by switching to the task
 540:../src/cc3000_spi.c **** 		// and calling from task Event Handler
 541:../src/cc3000_spi.c **** 		//
 542:../src/cc3000_spi.c **** 		if (ucRxFinished)
 1240              		.loc 1 542 0
 1241 00de 3B68     		ldr	r3, [r7, #0]
 1242 00e0 002B     		cmp	r3, #0
 1243 00e2 54D0     		beq	.L54
 543:../src/cc3000_spi.c **** 		{
 544:../src/cc3000_spi.c **** 			/* Clear SPI_DMA Interrupt Pending Flags */
 545:../src/cc3000_spi.c **** 			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 1244              		.loc 1 545 0
 1245 00e4 4FF40830 		mov	r0, #139264
 1246 00e8 FFF7FEFF 		bl	DMA_ClearFlag
 546:../src/cc3000_spi.c **** 
 547:../src/cc3000_spi.c **** 			SpiTriggerRxProcessing();
 1247              		.loc 1 547 0
 1248 00ec FFF7FEFF 		bl	SpiTriggerRxProcessing
 1249 00f0 4DE0     		b	.L54
 1250              	.L59:
 548:../src/cc3000_spi.c **** 		}
 549:../src/cc3000_spi.c **** 	}
 550:../src/cc3000_spi.c **** 	else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_EOT)
 1251              		.loc 1 550 0
 1252 00f2 40F20003 		movw	r3, #:lower16:sSpiInformation
 1253 00f6 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1254 00fa 9B68     		ldr	r3, [r3, #8]
 1255 00fc 052B     		cmp	r3, #5
 1256 00fe 22D1     		bne	.L60
 551:../src/cc3000_spi.c **** 	{
 552:../src/cc3000_spi.c **** 		if (ucTxFinished)
 1257              		.loc 1 552 0
 1258 0100 7B68     		ldr	r3, [r7, #4]
 1259 0102 002B     		cmp	r3, #0
 1260 0104 43D0     		beq	.L54
 553:../src/cc3000_spi.c **** 		{
 554:../src/cc3000_spi.c **** 			/* Loop until SPI busy */
 555:../src/cc3000_spi.c **** 			while (SPI_I2S_GetFlagStatus(CC3000_SPI, SPI_I2S_FLAG_BSY ) != RESET)
 1261              		.loc 1 555 0
 1262 0106 00BF     		nop
 1263              	.L61:
 1264              		.loc 1 555 0 is_stmt 0 discriminator 1
 1265 0108 4FF46050 		mov	r0, #14336
 1266 010c C4F20000 		movt	r0, 16384
 1267 0110 4FF08001 		mov	r1, #128
 1268 0114 FFF7FEFF 		bl	SPI_I2S_GetFlagStatus
 1269 0118 0346     		mov	r3, r0
 1270 011a 002B     		cmp	r3, #0
 1271 011c F4D1     		bne	.L61
 556:../src/cc3000_spi.c **** 			{
 557:../src/cc3000_spi.c **** 			}
 558:../src/cc3000_spi.c **** 
 559:../src/cc3000_spi.c **** 			/* Clear SPI_DMA Interrupt Pending Flags */
 560:../src/cc3000_spi.c **** 			DMA_ClearFlag(CC3000_SPI_TX_DMA_TCFLAG | CC3000_SPI_RX_DMA_TCFLAG);
 1272              		.loc 1 560 0 is_stmt 1
 1273 011e 4FF40830 		mov	r0, #139264
 1274 0122 FFF7FEFF 		bl	DMA_ClearFlag
 561:../src/cc3000_spi.c **** 
 562:../src/cc3000_spi.c **** 			DEASSERT_CS();
 1275              		.loc 1 562 0
 1276 0126 4FF44060 		mov	r0, #3072
 1277 012a C4F20100 		movt	r0, 16385
 1278 012e 4FF48051 		mov	r1, #4096
 1279 0132 FFF7FEFF 		bl	GPIO_SetBits
 563:../src/cc3000_spi.c **** 
 564:../src/cc3000_spi.c **** 			sSpiInformation.ulSpiState = eSPI_STATE_IDLE;
 1280              		.loc 1 564 0
 1281 0136 40F20003 		movw	r3, #:lower16:sSpiInformation
 1282 013a C0F20003 		movt	r3, #:upper16:sSpiInformation
 1283 013e 4FF00202 		mov	r2, #2
 1284 0142 9A60     		str	r2, [r3, #8]
 1285 0144 23E0     		b	.L54
 1286              	.L60:
 565:../src/cc3000_spi.c **** 		}
 566:../src/cc3000_spi.c **** 	}
 567:../src/cc3000_spi.c **** 	else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_FIRST_PORTION)
 1287              		.loc 1 567 0
 1288 0146 40F20003 		movw	r3, #:lower16:sSpiInformation
 1289 014a C0F20003 		movt	r3, #:upper16:sSpiInformation
 1290 014e 9B68     		ldr	r3, [r3, #8]
 1291 0150 042B     		cmp	r3, #4
 1292 0152 1CD1     		bne	.L54
 568:../src/cc3000_spi.c **** 	{
 569:../src/cc3000_spi.c **** 		if (ucTxFinished)
 1293              		.loc 1 569 0
 1294 0154 7B68     		ldr	r3, [r7, #4]
 1295 0156 002B     		cmp	r3, #0
 1296 0158 19D0     		beq	.L54
 570:../src/cc3000_spi.c **** 		{
 571:../src/cc3000_spi.c **** 			sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
 1297              		.loc 1 571 0
 1298 015a 40F20003 		movw	r3, #:lower16:sSpiInformation
 1299 015e C0F20003 		movt	r3, #:upper16:sSpiInformation
 1300 0162 4FF00502 		mov	r2, #5
 1301 0166 9A60     		str	r2, [r3, #8]
 572:../src/cc3000_spi.c **** 			SpiWriteAsync(sSpiInformation.pTxPacket + SPI_WINDOW_SIZE, sSpiInformation.usTxPacketLength - SP
 1302              		.loc 1 572 0
 1303 0168 40F20003 		movw	r3, #:lower16:sSpiInformation
 1304 016c C0F20003 		movt	r3, #:upper16:sSpiInformation
 1305 0170 DB68     		ldr	r3, [r3, #12]
 1306 0172 03F58062 		add	r2, r3, #1024
 1307 0176 40F20003 		movw	r3, #:lower16:sSpiInformation
 1308 017a C0F20003 		movt	r3, #:upper16:sSpiInformation
 1309 017e 9B88     		ldrh	r3, [r3, #4]
 1310 0180 A3F58063 		sub	r3, r3, #1024
 1311 0184 9BB2     		uxth	r3, r3
 1312 0186 1046     		mov	r0, r2
 1313 0188 1946     		mov	r1, r3
 1314 018a FFF7FEFF 		bl	SpiWriteAsync
 1315              	.L54:
 573:../src/cc3000_spi.c **** 		}
 574:../src/cc3000_spi.c **** 	}
 575:../src/cc3000_spi.c **** }
 1316              		.loc 1 575 0
 1317 018e 07F11007 		add	r7, r7, #16
 1318 0192 BD46     		mov	sp, r7
 1319 0194 80BD     		pop	{r7, pc}
 1320              		.cfi_endproc
 1321              	.LFE71:
 1323 0196 00BF     		.section	.text.SPI_EXTI_IntHandler,"ax",%progbits
 1324              		.align	2
 1325              		.global	SPI_EXTI_IntHandler
 1326              		.thumb
 1327              		.thumb_func
 1329              	SPI_EXTI_IntHandler:
 1330              	.LFB72:
 576:../src/cc3000_spi.c **** 
 577:../src/cc3000_spi.c **** /**
 578:../src/cc3000_spi.c ****  * @brief  The handler for Interrupt that is generated when CC3000 brings the
 579:../src/cc3000_spi.c ****  IRQ line low.
 580:../src/cc3000_spi.c ****  * @param  None
 581:../src/cc3000_spi.c ****  * @retval None
 582:../src/cc3000_spi.c ****  */
 583:../src/cc3000_spi.c **** void SPI_EXTI_IntHandler(void)
 584:../src/cc3000_spi.c **** {
 1331              		.loc 1 584 0
 1332              		.cfi_startproc
 1333              		@ args = 0, pretend = 0, frame = 0
 1334              		@ frame_needed = 1, uses_anonymous_args = 0
 1335 0000 80B5     		push	{r7, lr}
 1336              	.LCFI42:
 1337              		.cfi_def_cfa_offset 8
 1338              		.cfi_offset 7, -8
 1339              		.cfi_offset 14, -4
 1340 0002 00AF     		add	r7, sp, #0
 1341              	.LCFI43:
 1342              		.cfi_def_cfa_register 7
 585:../src/cc3000_spi.c **** 	//Flag is cleared in first ISR handler
 586:../src/cc3000_spi.c **** 	if (!tSLInformation.ReadWlanInterruptPin())
 1343              		.loc 1 586 0
 1344 0004 40F20003 		movw	r3, #:lower16:tSLInformation
 1345 0008 C0F20003 		movt	r3, #:upper16:tSLInformation
 1346 000c DB69     		ldr	r3, [r3, #28]
 1347 000e 9847     		blx	r3
 1348 0010 0346     		mov	r3, r0
 1349 0012 002B     		cmp	r3, #0
 1350 0014 5FD1     		bne	.L62
 587:../src/cc3000_spi.c **** 	{
 588:../src/cc3000_spi.c **** 		if (sSpiInformation.ulSpiState == eSPI_STATE_POWERUP)
 1351              		.loc 1 588 0
 1352 0016 40F20003 		movw	r3, #:lower16:sSpiInformation
 1353 001a C0F20003 		movt	r3, #:upper16:sSpiInformation
 1354 001e 9B68     		ldr	r3, [r3, #8]
 1355 0020 002B     		cmp	r3, #0
 1356 0022 07D1     		bne	.L64
 589:../src/cc3000_spi.c **** 		{
 590:../src/cc3000_spi.c **** 			/* This means IRQ line was low call a callback of HCI Layer to inform on event */
 591:../src/cc3000_spi.c **** 			sSpiInformation.ulSpiState = eSPI_STATE_INITIALIZED;
 1357              		.loc 1 591 0
 1358 0024 40F20003 		movw	r3, #:lower16:sSpiInformation
 1359 0028 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1360 002c 4FF00102 		mov	r2, #1
 1361 0030 9A60     		str	r2, [r3, #8]
 1362 0032 50E0     		b	.L62
 1363              	.L64:
 592:../src/cc3000_spi.c **** 		}
 593:../src/cc3000_spi.c **** 		else if (sSpiInformation.ulSpiState == eSPI_STATE_IDLE)
 1364              		.loc 1 593 0
 1365 0034 40F20003 		movw	r3, #:lower16:sSpiInformation
 1366 0038 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1367 003c 9B68     		ldr	r3, [r3, #8]
 1368 003e 022B     		cmp	r3, #2
 1369 0040 11D1     		bne	.L65
 594:../src/cc3000_spi.c **** 		{
 595:../src/cc3000_spi.c **** 			sSpiInformation.ulSpiState = eSPI_STATE_READ_IRQ;
 1370              		.loc 1 595 0
 1371 0042 40F20003 		movw	r3, #:lower16:sSpiInformation
 1372 0046 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1373 004a 4FF00602 		mov	r2, #6
 1374 004e 9A60     		str	r2, [r3, #8]
 596:../src/cc3000_spi.c **** 
 597:../src/cc3000_spi.c **** 			/* IRQ line goes down - we are starting reception */
 598:../src/cc3000_spi.c **** 
 599:../src/cc3000_spi.c **** 			ASSERT_CS();
 1375              		.loc 1 599 0
 1376 0050 4FF44060 		mov	r0, #3072
 1377 0054 C4F20100 		movt	r0, 16385
 1378 0058 4FF48051 		mov	r1, #4096
 1379 005c FFF7FEFF 		bl	GPIO_ResetBits
 600:../src/cc3000_spi.c **** 
 601:../src/cc3000_spi.c **** 			//
 602:../src/cc3000_spi.c **** 			// Wait for TX/RX Complete which will come as DMA interrupt
 603:../src/cc3000_spi.c **** 			//
 604:../src/cc3000_spi.c **** 			SpiReadHeader();
 1380              		.loc 1 604 0
 1381 0060 FFF7FEFF 		bl	SpiReadHeader
 1382 0064 37E0     		b	.L62
 1383              	.L65:
 605:../src/cc3000_spi.c **** 		}
 606:../src/cc3000_spi.c **** 		else if (sSpiInformation.ulSpiState == eSPI_STATE_WRITE_IRQ)
 1384              		.loc 1 606 0
 1385 0066 40F20003 		movw	r3, #:lower16:sSpiInformation
 1386 006a C0F20003 		movt	r3, #:upper16:sSpiInformation
 1387 006e 9B68     		ldr	r3, [r3, #8]
 1388 0070 032B     		cmp	r3, #3
 1389 0072 30D1     		bne	.L62
 607:../src/cc3000_spi.c **** 		{
 608:../src/cc3000_spi.c **** 			if (sSpiInformation.usTxPacketLength <= SPI_WINDOW_SIZE)
 1390              		.loc 1 608 0
 1391 0074 40F20003 		movw	r3, #:lower16:sSpiInformation
 1392 0078 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1393 007c 9B88     		ldrh	r3, [r3, #4]
 1394 007e B3F5806F 		cmp	r3, #1024
 1395 0082 17D8     		bhi	.L66
 609:../src/cc3000_spi.c **** 			{
 610:../src/cc3000_spi.c **** 				//
 611:../src/cc3000_spi.c **** 				// Send the data over SPI and wait for complete interrupt
 612:../src/cc3000_spi.c **** 				//
 613:../src/cc3000_spi.c **** 				sSpiInformation.ulSpiState = eSPI_STATE_WRITE_EOT;
 1396              		.loc 1 613 0
 1397 0084 40F20003 		movw	r3, #:lower16:sSpiInformation
 1398 0088 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1399 008c 4FF00502 		mov	r2, #5
 1400 0090 9A60     		str	r2, [r3, #8]
 614:../src/cc3000_spi.c **** 
 615:../src/cc3000_spi.c **** 				SpiReadWriteStringInt(FALSE, sSpiInformation.pTxPacket, sSpiInformation.usTxPacketLength);
 1401              		.loc 1 615 0
 1402 0092 40F20003 		movw	r3, #:lower16:sSpiInformation
 1403 0096 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1404 009a DA68     		ldr	r2, [r3, #12]
 1405 009c 40F20003 		movw	r3, #:lower16:sSpiInformation
 1406 00a0 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1407 00a4 9B88     		ldrh	r3, [r3, #4]
 1408 00a6 4FF00000 		mov	r0, #0
 1409 00aa 1146     		mov	r1, r2
 1410 00ac 1A46     		mov	r2, r3
 1411 00ae FFF7FEFF 		bl	SpiReadWriteStringInt
 1412 00b2 10E0     		b	.L62
 1413              	.L66:
 616:../src/cc3000_spi.c **** 
 617:../src/cc3000_spi.c **** 			}
 618:../src/cc3000_spi.c **** 			else
 619:../src/cc3000_spi.c **** 			{
 620:../src/cc3000_spi.c **** 				//
 621:../src/cc3000_spi.c **** 				// Send the data over SPI and wait for complete interrupt to transfer the rest
 622:../src/cc3000_spi.c **** 				//
 623:../src/cc3000_spi.c **** 				sSpiInformation.ulSpiState = eSPI_STATE_WRITE_FIRST_PORTION;
 1414              		.loc 1 623 0
 1415 00b4 40F20003 		movw	r3, #:lower16:sSpiInformation
 1416 00b8 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1417 00bc 4FF00402 		mov	r2, #4
 1418 00c0 9A60     		str	r2, [r3, #8]
 624:../src/cc3000_spi.c **** 
 625:../src/cc3000_spi.c **** 				//
 626:../src/cc3000_spi.c **** 				// Start the DMA and change state
 627:../src/cc3000_spi.c **** 				//
 628:../src/cc3000_spi.c **** 				SpiWriteAsync(sSpiInformation.pTxPacket, SPI_WINDOW_SIZE);
 1419              		.loc 1 628 0
 1420 00c2 40F20003 		movw	r3, #:lower16:sSpiInformation
 1421 00c6 C0F20003 		movt	r3, #:upper16:sSpiInformation
 1422 00ca DB68     		ldr	r3, [r3, #12]
 1423 00cc 1846     		mov	r0, r3
 1424 00ce 4FF48061 		mov	r1, #1024
 1425 00d2 FFF7FEFF 		bl	SpiWriteAsync
 1426              	.L62:
 629:../src/cc3000_spi.c **** 			}
 630:../src/cc3000_spi.c **** 		}
 631:../src/cc3000_spi.c **** 	}
 632:../src/cc3000_spi.c **** }
 1427              		.loc 1 632 0
 1428 00d6 80BD     		pop	{r7, pc}
 1429              		.cfi_endproc
 1430              	.LFE72:
 1432              		.text
 1433              	.Letext0:
 1434              		.file 3 "/usr/local/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../../ar
 1435              		.file 4 "/Users/zac/code/spark/marvin/libraries/CMSIS/Device/ST/STM32F10x/Include/stm32f10x.h"
 1436              		.file 5 "/Users/zac/code/spark/marvin/libraries/CC3000_Host_Driver/cc3000_common.h"
 1437              		.file 6 "/Users/zac/code/spark/marvin/inc/hw_config.h"
 1438              		.file 7 "/Users/zac/code/spark/marvin/inc/cc3000_spi.h"
 1439              		.file 8 "/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cm3.h"
 1440              		.file 9 "/Users/zac/code/spark/marvin/libraries/CMSIS/Device/ST/STM32F10x/Include/system_stm32f10x
DEFINED SYMBOLS
                            *ABS*:0000000000000000 cc3000_spi.c
                            *COM*:0000000000000400 wlan_rx_buffer
                            *COM*:0000000000000400 wlan_tx_buffer
                            *COM*:0000000000000014 sSpiInformation
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:26     .data:0000000000000000 tSpiReadHeader
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:23     .data:0000000000000000 $d
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:33     .text.SysCtlDelay:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:38     .text.SysCtlDelay:0000000000000000 SysCtlDelay
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:78     .text.SpiOpen:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:83     .text.SpiOpen:0000000000000000 SpiOpen
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:145    .text.SpiClose:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:150    .text.SpiClose:0000000000000000 SpiClose
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:187    .text.SpiResumeSpi:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:192    .text.SpiResumeSpi:0000000000000000 SpiResumeSpi
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:224    .text.SpiPauseSpi:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:229    .text.SpiPauseSpi:0000000000000000 SpiPauseSpi
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:260    .text.SpiTriggerRxProcessing:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:265    .text.SpiTriggerRxProcessing:0000000000000000 SpiTriggerRxProcessing
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:307    .text.SpiReadData:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:312    .text.SpiReadData:0000000000000000 SpiReadData
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:390    .text.SpiReadWriteStringInt:0000000000000000 SpiReadWriteStringInt
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:346    .text.SpiWriteAsync:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:351    .text.SpiWriteAsync:0000000000000000 SpiWriteAsync
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:518    .text.SpiReadWriteString:0000000000000000 SpiReadWriteString
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:385    .text.SpiReadWriteStringInt:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:513    .text.SpiReadWriteString:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:635    .text.SpiFirstWrite:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:640    .text.SpiFirstWrite:0000000000000000 SpiFirstWrite
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:700    .text.SpiWrite:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:705    .text.SpiWrite:0000000000000000 SpiWrite
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:901    .text.SpiReadDataCont:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:906    .text.SpiReadDataCont:0000000000000000 SpiReadDataCont
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1056   .text.SpiReadHeader:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1061   .text.SpiReadHeader:0000000000000000 SpiReadHeader
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1089   .text.SpiContReadOperation:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1094   .text.SpiContReadOperation:0000000000000000 SpiContReadOperation
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1122   .text.SPI_DMA_IntHandler:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1127   .text.SPI_DMA_IntHandler:0000000000000000 SPI_DMA_IntHandler
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1324   .text.SPI_EXTI_IntHandler:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//cczLDCWY.s:1329   .text.SPI_EXTI_IntHandler:0000000000000000 SPI_EXTI_IntHandler
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.1.8991b0b359e9e91a82acb66692cb6642
                           .group:0000000000000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:0000000000000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:0000000000000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:0000000000000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:0000000000000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:0000000000000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:0000000000000000 wm4.stddef.h.349.31f4c5baff3fa2689010b32028da9c47
                           .group:0000000000000000 wm4.reent.h.16.9e42f0e588b85e70b2bf6572af57ce64
                           .group:0000000000000000 wm4.stddef.h.187.9e651b6b8b16e149c1353259404973ea
                           .group:0000000000000000 wm4.string.h.17.f8d12df81104836a3f2a5d589ae830d8
                           .group:0000000000000000 wm4.platform_config.h.13.23e06e06852a155ef1a4458870bf98fa
                           .group:0000000000000000 wm4.stm32f10x.h.57.69ab29c83f735418a543aa508b559235
                           .group:0000000000000000 wm4.core_cm3.h.32.8e21fbd14bb96c2b40e026c4d2c8fe1f
                           .group:0000000000000000 wm4.stdint.h.10.90b695f550ca6cc3fb08fa83baf01e05
                           .group:0000000000000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:0000000000000000 wm4.core_cm3.h.129.e08b7204181ea22e6a9fa84cb9ad0924
                           .group:0000000000000000 wm4.stm32f10x.h.532.91bd57525f6c583f00129a351847d405
                           .group:0000000000000000 wm4.stm32f10x_adc.h.89.9f2b285fa0070185d48a05b61a05798c
                           .group:0000000000000000 wm4.stm32f10x_bkp.h.31.74a586c036c8ee5d9205c6728cc8d6ab
                           .group:0000000000000000 wm4.stm32f10x_dma.h.31.ef16218235edc52b414c0353f44b4bf0
                           .group:0000000000000000 wm4.stm32f10x_exti.h.31.b25bcb4f1a2daad39d2d7dfa4e901646
                           .group:0000000000000000 wm4.stm32f10x_flash.h.31.0203bc95b65c5396b67991e07a675efb
                           .group:0000000000000000 wm4.stm32f10x_gpio.h.31.0a32659dbac1fc1055c7cbdc248963be
                           .group:0000000000000000 wm4.stm32f10x_i2c.h.31.93d7dc2d477856f119d957730d4c6f1c
                           .group:0000000000000000 wm4.stm32f10x_pwr.h.31.9168b6921e0cf03b467c7ed90861c701
                           .group:0000000000000000 wm4.stm32f10x_rcc.h.31.2ee3219a25ef4ced658f2fe9d8cd94aa
                           .group:0000000000000000 wm4.stm32f10x_rtc.h.31.00ba78fc0dbb06b6e6783a1e7fccf5a0
                           .group:0000000000000000 wm4.stm32f10x_spi.h.31.d2f6e4626887cabe8c98f3a185590a36
                           .group:0000000000000000 wm4.stm32f10x_tim.h.31.6c06f7f26e0864f9cd59597f46ca2c7c
                           .group:0000000000000000 wm4.stm32f10x_usart.h.31.28d75d6af05cefbbfa00cf30a7c8a335
                           .group:0000000000000000 wm4.misc.h.31.a89fba2040036f6f8c835a78a213e0cd
                           .group:0000000000000000 wm4.stm32f10x.h.8356.9fd2fa84655112ac7dfc5c88beeb383d
                           .group:0000000000000000 wm4.platform_config.h.55.c9956ee2c5ec010802c11a3a06087af4
                           .group:0000000000000000 wm4.stdlib.h.13.603ed7eb09a1561ab06840b7c0fcff58
                           .group:0000000000000000 wm4.stddef.h.235.fb53403984550eba259277227435d55a
                           .group:0000000000000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:0000000000000000 wm4.stdlib.h.53.c69c7609933ff56d59c757cec2d13230
                           .group:0000000000000000 wm4.errno.h.2.ba016d646105af6cad23be83630b6a3f
                           .group:0000000000000000 wm4.errno.h.9.65044c2b5d8494e43f5986ab0a1d770f
                           .group:0000000000000000 wm4.cc3000_common.h.58.2af7f8f8921b8cb4b89883c25878e207
                           .group:0000000000000000 wm4.usb_conf.h.13.ae0ffce2e8d0e4c6b2724f8ae0ada8cf
                           .group:0000000000000000 wm4.hw_config.h.61.9aaf7ecb821816183829c116d76d82b5
                           .group:0000000000000000 wm4.hci.h.51.9deb4690145bc08404ecd70e8dadf8e4
                           .group:0000000000000000 wm4.wlan.h.36.4c6fda3ef88238c289a06e4d08269130
                           .group:0000000000000000 wm4.cc3000_spi.h.23.1c29ffde27bc0db6b69332f529b4950f

UNDEFINED SYMBOLS
tSLInformation
GPIO_SetBits
SystemCoreClock
CC3000_SPI_DMA_Channels
CC3000_DMA_Config
DMA_ITConfig
DMA_GetCurrDataCounter
SPI_I2S_GetFlagStatus
GPIO_ResetBits
STREAM_TO_UINT16_f
DMA_GetFlagStatus
DMA_ClearFlag
