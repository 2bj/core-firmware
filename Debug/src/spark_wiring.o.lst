   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"spark_wiring.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	adcInitFirstTime
  19              		.data
  22              	adcInitFirstTime:
  23 0000 01       		.byte	1
  24              		.global	adcChannelConfigured
  27              	adcChannelConfigured:
  28 0001 FF       		.byte	-1
  29              		.global	digitalPinModeSaved
  32              	digitalPinModeSaved:
  33 0002 FF       		.byte	-1
  34              		.global	serial1_enabled
  35              		.bss
  38              	serial1_enabled:
  39 0000 00       		.space	1
  40              		.global	PIN_MAP
  41              		.data
  42 0003 00       		.align	2
  45              	PIN_MAP:
  46 0004 000C0140 		.word	1073810432
  47 0008 8000     		.short	128
  48 000a FF       		.byte	-1
  49 000b 00       		.space	1
  50 000c 00080040 		.word	1073743872
  51 0010 0400     		.short	4
  52 0012 FF       		.byte	-1
  53 0013 00       		.space	1
  54 0014 000C0140 		.word	1073810432
  55 0018 4000     		.short	64
  56 001a FF       		.byte	-1
  57 001b 00       		.space	1
  58 001c 00080040 		.word	1073743872
  59 0020 0000     		.short	0
  60 0022 FF       		.byte	-1
  61 0023 00       		.space	1
  62 0024 000C0140 		.word	1073810432
  63 0028 2000     		.short	32
  64 002a FF       		.byte	-1
  65 002b 00       		.space	1
  66 002c 00000000 		.word	0
  67 0030 FF00     		.short	255
  68 0032 FF       		.byte	-1
  69 0033 00       		.space	1
  70 0034 000C0140 		.word	1073810432
  71 0038 1000     		.short	16
  72 003a FF       		.byte	-1
  73 003b 00       		.space	1
  74 003c 00000000 		.word	0
  75 0040 FF00     		.short	255
  76 0042 FF       		.byte	-1
  77 0043 00       		.space	1
  78 0044 000C0140 		.word	1073810432
  79 0048 0800     		.short	8
  80 004a FF       		.byte	-1
  81 004b 00       		.space	1
  82 004c 00000000 		.word	0
  83 0050 FF00     		.short	255
  84 0052 FF       		.byte	-1
  85 0053 00       		.space	1
  86 0054 00080140 		.word	1073809408
  87 0058 0080     		.short	-32768
  88 005a FF       		.byte	-1
  89 005b 00       		.space	1
  90 005c 00000000 		.word	0
  91 0060 FF00     		.short	255
  92 0062 FF       		.byte	-1
  93 0063 00       		.space	1
  94 0064 00080140 		.word	1073809408
  95 0068 0040     		.short	16384
  96 006a FF       		.byte	-1
  97 006b 00       		.space	1
  98 006c 00000000 		.word	0
  99 0070 FF00     		.short	255
 100 0072 FF       		.byte	-1
 101 0073 00       		.space	1
 102 0074 00080140 		.word	1073809408
 103 0078 0020     		.short	8192
 104 007a FF       		.byte	-1
 105 007b 00       		.space	1
 106 007c 00000000 		.word	0
 107 0080 FF00     		.short	255
 108 0082 FF       		.byte	-1
 109 0083 00       		.space	1
 110 0084 00080140 		.word	1073809408
 111 0088 0001     		.short	256
 112 008a FF       		.byte	-1
 113 008b 00       		.space	1
 114 008c 00000000 		.word	0
 115 0090 FF00     		.short	255
 116 0092 FF       		.byte	-1
 117 0093 00       		.space	1
 118 0094 00080140 		.word	1073809408
 119 0098 0002     		.short	512
 120 009a FF       		.byte	-1
 121 009b 00       		.space	1
 122 009c 00000000 		.word	0
 123 00a0 FF00     		.short	255
 124 00a2 FF       		.byte	-1
 125 00a3 00       		.space	1
 126 00a4 00080140 		.word	1073809408
 127 00a8 0100     		.short	1
 128 00aa 00       		.byte	0
 129 00ab 00       		.space	1
 130 00ac 00000040 		.word	1073741824
 131 00b0 0000     		.short	0
 132 00b2 FF       		.byte	-1
 133 00b3 00       		.space	1
 134 00b4 00080140 		.word	1073809408
 135 00b8 0200     		.short	2
 136 00ba 01       		.byte	1
 137 00bb 00       		.space	1
 138 00bc 00000040 		.word	1073741824
 139 00c0 0400     		.short	4
 140 00c2 FF       		.byte	-1
 141 00c3 00       		.space	1
 142 00c4 00080140 		.word	1073809408
 143 00c8 1000     		.short	16
 144 00ca 04       		.byte	4
 145 00cb 00       		.space	1
 146 00cc 00000000 		.word	0
 147 00d0 FF00     		.short	255
 148 00d2 FF       		.byte	-1
 149 00d3 00       		.space	1
 150 00d4 00080140 		.word	1073809408
 151 00d8 2000     		.short	32
 152 00da 05       		.byte	5
 153 00db 00       		.space	1
 154 00dc 00000000 		.word	0
 155 00e0 FF00     		.short	255
 156 00e2 FF       		.byte	-1
 157 00e3 00       		.space	1
 158 00e4 00080140 		.word	1073809408
 159 00e8 4000     		.short	64
 160 00ea 06       		.byte	6
 161 00eb 00       		.space	1
 162 00ec 00040040 		.word	1073742848
 163 00f0 0000     		.short	0
 164 00f2 FF       		.byte	-1
 165 00f3 00       		.space	1
 166 00f4 00080140 		.word	1073809408
 167 00f8 8000     		.short	128
 168 00fa 07       		.byte	7
 169 00fb 00       		.space	1
 170 00fc 00040040 		.word	1073742848
 171 0100 0400     		.short	4
 172 0102 FF       		.byte	-1
 173 0103 00       		.space	1
 174 0104 000C0140 		.word	1073810432
 175 0108 0100     		.short	1
 176 010a 08       		.byte	8
 177 010b 00       		.space	1
 178 010c 00040040 		.word	1073742848
 179 0110 0800     		.short	8
 180 0112 FF       		.byte	-1
 181 0113 00       		.space	1
 182 0114 000C0140 		.word	1073810432
 183 0118 0200     		.short	2
 184 011a 09       		.byte	9
 185 011b 00       		.space	1
 186 011c 00040040 		.word	1073742848
 187 0120 0C00     		.short	12
 188 0122 FF       		.byte	-1
 189 0123 00       		.space	1
 190 0124 00080140 		.word	1073809408
 191 0128 0800     		.short	8
 192 012a 03       		.byte	3
 193 012b 00       		.space	1
 194 012c 00000040 		.word	1073741824
 195 0130 0C00     		.short	12
 196 0132 FF       		.byte	-1
 197 0133 00       		.space	1
 198 0134 00080140 		.word	1073809408
 199 0138 0400     		.short	4
 200 013a 02       		.byte	2
 201 013b 00       		.space	1
 202 013c 00000040 		.word	1073741824
 203 0140 0800     		.short	8
 204 0142 FF       		.byte	-1
 205 0143 00       		.space	1
 206 0144 00080140 		.word	1073809408
 207 0148 0004     		.short	1024
 208 014a FF       		.byte	-1
 209 014b 00       		.space	1
 210 014c 00000000 		.word	0
 211 0150 FF00     		.short	255
 212 0152 FF       		.byte	-1
 213 0153 00       		.space	1
 214              		.global	Serial
 215              		.align	2
 218              	Serial:
 219 0154 00000000 		.word	serial_begin
 220 0158 00000000 		.word	serial_end
 221 015c 00000000 		.word	serial_available
 222 0160 00000000 		.word	serial_read
 223 0164 00000000 		.word	serial_write
 224 0168 00000000 		.word	serial_print
 225 016c 00000000 		.word	serial_println
 226              		.global	Serial1
 227              		.align	2
 230              	Serial1:
 231 0170 00000000 		.word	serial1_begin
 232 0174 00000000 		.word	serial1_end
 233 0178 00000000 		.word	serial1_available
 234 017c 00000000 		.word	serial1_read
 235 0180 00000000 		.word	serial1_write
 236 0184 00000000 		.word	serial1_print
 237 0188 00000000 		.word	serial1_println
 238              		.section	.text.pinMode,"ax",%progbits
 239              		.align	2
 240              		.global	pinMode
 241              		.thumb
 242              		.thumb_func
 244              	pinMode:
 245              	.LFB56:
 246              		.file 1 "../src/spark_wiring.c"
   1:../src/spark_wiring.c **** /*
   2:../src/spark_wiring.c ****  * spark_wiring.c
   3:../src/spark_wiring.c ****  *
   4:../src/spark_wiring.c ****  *  Created on: Apr 15, 2013
   5:../src/spark_wiring.c ****  *      Author: zsupalla
   6:../src/spark_wiring.c ****  *      Updated: satishgn
   7:../src/spark_wiring.c ****  */
   8:../src/spark_wiring.c **** 
   9:../src/spark_wiring.c **** #include "spark_wiring.h"
  10:../src/spark_wiring.c **** 
  11:../src/spark_wiring.c **** /*
  12:../src/spark_wiring.c ****  * Globals
  13:../src/spark_wiring.c ****  */
  14:../src/spark_wiring.c **** 
  15:../src/spark_wiring.c **** uint8_t adcInitFirstTime = true;
  16:../src/spark_wiring.c **** uint8_t adcChannelConfigured = NONE;
  17:../src/spark_wiring.c **** 
  18:../src/spark_wiring.c **** PinMode digitalPinModeSaved = NONE;
  19:../src/spark_wiring.c **** 
  20:../src/spark_wiring.c **** uint8_t serial1_enabled = false;
  21:../src/spark_wiring.c **** 
  22:../src/spark_wiring.c **** extern __IO uint32_t TimingMillis;
  23:../src/spark_wiring.c **** 
  24:../src/spark_wiring.c **** /*
  25:../src/spark_wiring.c ****  * Pin mapping
  26:../src/spark_wiring.c ****  */
  27:../src/spark_wiring.c **** 
  28:../src/spark_wiring.c **** STM32_Pin_Info PIN_MAP[TOTAL_PINS] =
  29:../src/spark_wiring.c **** {
  30:../src/spark_wiring.c **** /*
  31:../src/spark_wiring.c ****  * gpio_peripheral (GPIOA or GPIOB; not using GPIOC)
  32:../src/spark_wiring.c ****  * gpio_pin (0-15)
  33:../src/spark_wiring.c ****  * adc_channel (0-9 or NONE. Note we don't define the peripheral because our chip only has one)
  34:../src/spark_wiring.c ****  * timer_peripheral (TIM2 - TIM4, or NONE)
  35:../src/spark_wiring.c ****  * timer_ch (1-4, or NONE)
  36:../src/spark_wiring.c ****  * pin_mode (NONE by default, can be set to OUTPUT, INPUT, or other types)
  37:../src/spark_wiring.c ****  */
  38:../src/spark_wiring.c **** 	{ GPIOB, GPIO_Pin_7, NONE, TIM4, TIM_Channel_2, NONE },
  39:../src/spark_wiring.c **** 	{ GPIOB, GPIO_Pin_6, NONE, TIM4, TIM_Channel_1, NONE },
  40:../src/spark_wiring.c **** 	{ GPIOB, GPIO_Pin_5, NONE, NULL, NONE, NONE },
  41:../src/spark_wiring.c **** 	{ GPIOB, GPIO_Pin_4, NONE, NULL, NONE, NONE },
  42:../src/spark_wiring.c **** 	{ GPIOB, GPIO_Pin_3, NONE, NULL, NONE, NONE },
  43:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_15, NONE, NULL, NONE, NONE },
  44:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_14, NONE, NULL, NONE, NONE },
  45:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_13, NONE, NULL, NONE, NONE },
  46:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_8, NONE, NULL, NONE, NONE },
  47:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_9, NONE, NULL, NONE, NONE },
  48:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_0, ADC_Channel_0, TIM2, TIM_Channel_1, NONE },
  49:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_1, ADC_Channel_1, TIM2, TIM_Channel_2, NONE },
  50:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_4, ADC_Channel_4, NULL, NONE, NONE },
  51:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_5, ADC_Channel_5, NULL, NONE, NONE },
  52:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_6, ADC_Channel_6, TIM3, TIM_Channel_1, NONE },
  53:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_7, ADC_Channel_7, TIM3, TIM_Channel_2, NONE },
  54:../src/spark_wiring.c **** 	{ GPIOB, GPIO_Pin_0, ADC_Channel_8, TIM3, TIM_Channel_3, NONE },
  55:../src/spark_wiring.c **** 	{ GPIOB, GPIO_Pin_1, ADC_Channel_9, TIM3, TIM_Channel_4, NONE },
  56:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_3, ADC_Channel_3, TIM2, TIM_Channel_4, NONE },
  57:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_2, ADC_Channel_2, TIM2, TIM_Channel_3, NONE },
  58:../src/spark_wiring.c **** 	{ GPIOA, GPIO_Pin_10, NONE, NULL, NONE, NONE }
  59:../src/spark_wiring.c **** };
  60:../src/spark_wiring.c **** 
  61:../src/spark_wiring.c **** void serial_begin(uint32_t baudRate);
  62:../src/spark_wiring.c **** void serial_end(void);
  63:../src/spark_wiring.c **** uint8_t serial_available(void);
  64:../src/spark_wiring.c **** int32_t serial_read(void);
  65:../src/spark_wiring.c **** void serial_write(uint8_t Data);
  66:../src/spark_wiring.c **** void serial_print(const char * str);
  67:../src/spark_wiring.c **** void serial_println(const char * str);
  68:../src/spark_wiring.c **** 
  69:../src/spark_wiring.c **** void serial1_begin(uint32_t baudRate);
  70:../src/spark_wiring.c **** void serial1_end(void);
  71:../src/spark_wiring.c **** uint8_t serial1_available(void);
  72:../src/spark_wiring.c **** int32_t serial1_read(void);
  73:../src/spark_wiring.c **** void serial1_write(uint8_t Data);
  74:../src/spark_wiring.c **** void serial1_print(const char * str);
  75:../src/spark_wiring.c **** void serial1_println(const char * str);
  76:../src/spark_wiring.c **** 
  77:../src/spark_wiring.c **** /*
  78:../src/spark_wiring.c ****  * Serial Interfaces
  79:../src/spark_wiring.c ****  */
  80:../src/spark_wiring.c **** 
  81:../src/spark_wiring.c **** Serial_Interface Serial =
  82:../src/spark_wiring.c **** {
  83:../src/spark_wiring.c **** 	serial_begin,
  84:../src/spark_wiring.c **** 	serial_end,
  85:../src/spark_wiring.c **** 	serial_available,
  86:../src/spark_wiring.c **** 	serial_read,
  87:../src/spark_wiring.c **** 	serial_write,
  88:../src/spark_wiring.c **** 	serial_print,
  89:../src/spark_wiring.c **** 	serial_println
  90:../src/spark_wiring.c **** };
  91:../src/spark_wiring.c **** 
  92:../src/spark_wiring.c **** Serial_Interface Serial1 =
  93:../src/spark_wiring.c **** {
  94:../src/spark_wiring.c **** 	serial1_begin,
  95:../src/spark_wiring.c **** 	serial1_end,
  96:../src/spark_wiring.c **** 	serial1_available,
  97:../src/spark_wiring.c **** 	serial1_read,
  98:../src/spark_wiring.c **** 	serial1_write,
  99:../src/spark_wiring.c **** 	serial1_print,
 100:../src/spark_wiring.c **** 	serial1_println
 101:../src/spark_wiring.c **** };
 102:../src/spark_wiring.c **** 
 103:../src/spark_wiring.c **** /*
 104:../src/spark_wiring.c ****  * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP, or INPUT_PULLDOWN
 105:../src/spark_wiring.c ****  */
 106:../src/spark_wiring.c **** void pinMode(uint16_t pin, PinMode setMode)
 107:../src/spark_wiring.c **** {
 247              		.loc 1 107 0
 248              		.cfi_startproc
 249              		@ args = 0, pretend = 0, frame = 24
 250              		@ frame_needed = 1, uses_anonymous_args = 0
 251 0000 80B5     		push	{r7, lr}
 252              	.LCFI0:
 253              		.cfi_def_cfa_offset 8
 254              		.cfi_offset 7, -8
 255              		.cfi_offset 14, -4
 256 0002 86B0     		sub	sp, sp, #24
 257              	.LCFI1:
 258              		.cfi_def_cfa_offset 32
 259 0004 00AF     		add	r7, sp, #0
 260              	.LCFI2:
 261              		.cfi_def_cfa_register 7
 262 0006 0246     		mov	r2, r0
 263 0008 0B46     		mov	r3, r1
 264 000a FA80     		strh	r2, [r7, #6]	@ movhi
 265 000c 7B71     		strb	r3, [r7, #5]
 108:../src/spark_wiring.c **** 
 109:../src/spark_wiring.c **** 	if (pin >= TOTAL_PINS || setMode == NONE )
 266              		.loc 1 109 0
 267 000e FB88     		ldrh	r3, [r7, #6]
 268 0010 142B     		cmp	r3, #20
 269 0012 00F2CA80 		bhi	.L1
 270              		.loc 1 109 0 is_stmt 0 discriminator 1
 271 0016 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 272 0018 FF2B     		cmp	r3, #255
 273 001a 00F0C680 		beq	.L1
 110:../src/spark_wiring.c **** 	{
 111:../src/spark_wiring.c **** 		return;
 112:../src/spark_wiring.c **** 	}
 113:../src/spark_wiring.c **** 
 114:../src/spark_wiring.c **** 	// Serial1 safety check
 115:../src/spark_wiring.c **** 	if (serial1_enabled == true && (pin == RX || pin == TX))
 274              		.loc 1 115 0 is_stmt 1
 275 001e 40F20003 		movw	r3, #:lower16:serial1_enabled
 276 0022 C0F20003 		movt	r3, #:upper16:serial1_enabled
 277 0026 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 278 0028 012B     		cmp	r3, #1
 279 002a 07D1     		bne	.L3
 280              		.loc 1 115 0 is_stmt 0 discriminator 1
 281 002c FB88     		ldrh	r3, [r7, #6]
 282 002e 122B     		cmp	r3, #18
 283 0030 00F0BB80 		beq	.L1
 284 0034 FB88     		ldrh	r3, [r7, #6]
 285 0036 132B     		cmp	r3, #19
 286 0038 00F0B780 		beq	.L1
 287              	.L3:
 116:../src/spark_wiring.c **** 	{
 117:../src/spark_wiring.c **** 		return;
 118:../src/spark_wiring.c **** 	}
 119:../src/spark_wiring.c **** 
 120:../src/spark_wiring.c **** 	GPIO_TypeDef *gpio_port = PIN_MAP[pin].gpio_peripheral;
 288              		.loc 1 120 0 is_stmt 1
 289 003c FA88     		ldrh	r2, [r7, #6]
 290 003e 40F20003 		movw	r3, #:lower16:PIN_MAP
 291 0042 C0F20003 		movt	r3, #:upper16:PIN_MAP
 292 0046 4FEA0212 		lsl	r2, r2, #4
 293 004a 9B18     		adds	r3, r3, r2
 294 004c 1B68     		ldr	r3, [r3, #0]
 295 004e 7B61     		str	r3, [r7, #20]
 121:../src/spark_wiring.c **** 	uint16_t gpio_pin = PIN_MAP[pin].gpio_pin;
 296              		.loc 1 121 0
 297 0050 FA88     		ldrh	r2, [r7, #6]
 298 0052 40F20003 		movw	r3, #:lower16:PIN_MAP
 299 0056 C0F20003 		movt	r3, #:upper16:PIN_MAP
 300 005a 4FEA0212 		lsl	r2, r2, #4
 301 005e 9B18     		adds	r3, r3, r2
 302 0060 9B88     		ldrh	r3, [r3, #4]	@ movhi
 303 0062 7B82     		strh	r3, [r7, #18]	@ movhi
 122:../src/spark_wiring.c **** 
 123:../src/spark_wiring.c **** 	GPIO_InitTypeDef GPIO_InitStructure;
 124:../src/spark_wiring.c **** 
 125:../src/spark_wiring.c **** 	if (gpio_port == GPIOA )
 304              		.loc 1 125 0
 305 0064 7A69     		ldr	r2, [r7, #20]
 306 0066 4FF40063 		mov	r3, #2048
 307 006a C4F20103 		movt	r3, 16385
 308 006e 9A42     		cmp	r2, r3
 309 0070 06D1     		bne	.L4
 126:../src/spark_wiring.c **** 	{
 127:../src/spark_wiring.c **** 		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 310              		.loc 1 127 0
 311 0072 4FF00400 		mov	r0, #4
 312 0076 4FF00101 		mov	r1, #1
 313 007a FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 314 007e 0CE0     		b	.L5
 315              	.L4:
 128:../src/spark_wiring.c **** 	}
 129:../src/spark_wiring.c **** 	else if (gpio_port == GPIOB )
 316              		.loc 1 129 0
 317 0080 7A69     		ldr	r2, [r7, #20]
 318 0082 4FF44063 		mov	r3, #3072
 319 0086 C4F20103 		movt	r3, 16385
 320 008a 9A42     		cmp	r2, r3
 321 008c 05D1     		bne	.L5
 130:../src/spark_wiring.c **** 	{
 131:../src/spark_wiring.c **** 		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 322              		.loc 1 131 0
 323 008e 4FF00800 		mov	r0, #8
 324 0092 4FF00101 		mov	r1, #1
 325 0096 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 326              	.L5:
 132:../src/spark_wiring.c **** 	}
 133:../src/spark_wiring.c **** 
 134:../src/spark_wiring.c **** 	GPIO_InitStructure.GPIO_Pin = gpio_pin;
 327              		.loc 1 134 0
 328 009a 7B8A     		ldrh	r3, [r7, #18]	@ movhi
 329 009c BB81     		strh	r3, [r7, #12]	@ movhi
 135:../src/spark_wiring.c **** 
 136:../src/spark_wiring.c **** 	switch (setMode)
 330              		.loc 1 136 0
 331 009e 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 332 00a0 052B     		cmp	r3, #5
 333 00a2 7BD8     		bhi	.L16
 334 00a4 01A2     		adr	r2, .L13
 335 00a6 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 336 00aa 00BF     		.align	2
 337              	.L13:
 338 00ac C5000000 		.word	.L7+1
 339 00b0 ED000000 		.word	.L8+1
 340 00b4 0F010000 		.word	.L9+1
 341 00b8 31010000 		.word	.L10+1
 342 00bc 53010000 		.word	.L11+1
 343 00c0 7B010000 		.word	.L12+1
 344              	.L7:
 137:../src/spark_wiring.c **** 	{
 138:../src/spark_wiring.c **** 
 139:../src/spark_wiring.c **** 	case OUTPUT:
 140:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 345              		.loc 1 140 0
 346 00c4 4FF01003 		mov	r3, #16
 347 00c8 FB73     		strb	r3, [r7, #15]
 141:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 348              		.loc 1 141 0
 349 00ca 4FF00303 		mov	r3, #3
 350 00ce BB73     		strb	r3, [r7, #14]
 142:../src/spark_wiring.c **** 		PIN_MAP[pin].pin_mode = OUTPUT;
 351              		.loc 1 142 0
 352 00d0 FA88     		ldrh	r2, [r7, #6]
 353 00d2 40F20003 		movw	r3, #:lower16:PIN_MAP
 354 00d6 C0F20003 		movt	r3, #:upper16:PIN_MAP
 355 00da 4FEA0212 		lsl	r2, r2, #4
 356 00de 9B18     		adds	r3, r3, r2
 357 00e0 03F10803 		add	r3, r3, #8
 358 00e4 4FF00002 		mov	r2, #0
 359 00e8 9A71     		strb	r2, [r3, #6]
 143:../src/spark_wiring.c **** 		break;
 360              		.loc 1 143 0
 361 00ea 58E0     		b	.L14
 362              	.L8:
 144:../src/spark_wiring.c **** 
 145:../src/spark_wiring.c **** 	case INPUT:
 146:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 363              		.loc 1 146 0
 364 00ec 4FF00403 		mov	r3, #4
 365 00f0 FB73     		strb	r3, [r7, #15]
 147:../src/spark_wiring.c **** 		PIN_MAP[pin].pin_mode = INPUT;
 366              		.loc 1 147 0
 367 00f2 FA88     		ldrh	r2, [r7, #6]
 368 00f4 40F20003 		movw	r3, #:lower16:PIN_MAP
 369 00f8 C0F20003 		movt	r3, #:upper16:PIN_MAP
 370 00fc 4FEA0212 		lsl	r2, r2, #4
 371 0100 9B18     		adds	r3, r3, r2
 372 0102 03F10803 		add	r3, r3, #8
 373 0106 4FF00102 		mov	r2, #1
 374 010a 9A71     		strb	r2, [r3, #6]
 148:../src/spark_wiring.c **** 		break;
 375              		.loc 1 148 0
 376 010c 47E0     		b	.L14
 377              	.L9:
 149:../src/spark_wiring.c **** 
 150:../src/spark_wiring.c **** 	case INPUT_PULLUP:
 151:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 378              		.loc 1 151 0
 379 010e 4FF04803 		mov	r3, #72
 380 0112 FB73     		strb	r3, [r7, #15]
 152:../src/spark_wiring.c **** 		PIN_MAP[pin].pin_mode = INPUT_PULLUP;
 381              		.loc 1 152 0
 382 0114 FA88     		ldrh	r2, [r7, #6]
 383 0116 40F20003 		movw	r3, #:lower16:PIN_MAP
 384 011a C0F20003 		movt	r3, #:upper16:PIN_MAP
 385 011e 4FEA0212 		lsl	r2, r2, #4
 386 0122 9B18     		adds	r3, r3, r2
 387 0124 03F10803 		add	r3, r3, #8
 388 0128 4FF00202 		mov	r2, #2
 389 012c 9A71     		strb	r2, [r3, #6]
 153:../src/spark_wiring.c **** 		break;
 390              		.loc 1 153 0
 391 012e 36E0     		b	.L14
 392              	.L10:
 154:../src/spark_wiring.c **** 
 155:../src/spark_wiring.c **** 	case INPUT_PULLDOWN:
 156:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
 393              		.loc 1 156 0
 394 0130 4FF02803 		mov	r3, #40
 395 0134 FB73     		strb	r3, [r7, #15]
 157:../src/spark_wiring.c **** 		PIN_MAP[pin].pin_mode = INPUT_PULLDOWN;
 396              		.loc 1 157 0
 397 0136 FA88     		ldrh	r2, [r7, #6]
 398 0138 40F20003 		movw	r3, #:lower16:PIN_MAP
 399 013c C0F20003 		movt	r3, #:upper16:PIN_MAP
 400 0140 4FEA0212 		lsl	r2, r2, #4
 401 0144 9B18     		adds	r3, r3, r2
 402 0146 03F10803 		add	r3, r3, #8
 403 014a 4FF00302 		mov	r2, #3
 404 014e 9A71     		strb	r2, [r3, #6]
 158:../src/spark_wiring.c **** 		break;
 405              		.loc 1 158 0
 406 0150 25E0     		b	.L14
 407              	.L11:
 159:../src/spark_wiring.c **** 
 160:../src/spark_wiring.c **** 	case AF_OUTPUT:	//Used internally for Alternate Function Output(TIM, UART, SPI etc)
 161:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 408              		.loc 1 161 0
 409 0152 4FF01803 		mov	r3, #24
 410 0156 FB73     		strb	r3, [r7, #15]
 162:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 411              		.loc 1 162 0
 412 0158 4FF00303 		mov	r3, #3
 413 015c BB73     		strb	r3, [r7, #14]
 163:../src/spark_wiring.c **** 		PIN_MAP[pin].pin_mode = AF_OUTPUT;
 414              		.loc 1 163 0
 415 015e FA88     		ldrh	r2, [r7, #6]
 416 0160 40F20003 		movw	r3, #:lower16:PIN_MAP
 417 0164 C0F20003 		movt	r3, #:upper16:PIN_MAP
 418 0168 4FEA0212 		lsl	r2, r2, #4
 419 016c 9B18     		adds	r3, r3, r2
 420 016e 03F10803 		add	r3, r3, #8
 421 0172 4FF00402 		mov	r2, #4
 422 0176 9A71     		strb	r2, [r3, #6]
 164:../src/spark_wiring.c **** 		break;
 423              		.loc 1 164 0
 424 0178 11E0     		b	.L14
 425              	.L12:
 165:../src/spark_wiring.c **** 
 166:../src/spark_wiring.c **** 	case AN_INPUT:	//Used internally for ADC Input
 167:../src/spark_wiring.c **** 		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
 426              		.loc 1 167 0
 427 017a 4FF00003 		mov	r3, #0
 428 017e FB73     		strb	r3, [r7, #15]
 168:../src/spark_wiring.c **** 		PIN_MAP[pin].pin_mode = AN_INPUT;
 429              		.loc 1 168 0
 430 0180 FA88     		ldrh	r2, [r7, #6]
 431 0182 40F20003 		movw	r3, #:lower16:PIN_MAP
 432 0186 C0F20003 		movt	r3, #:upper16:PIN_MAP
 433 018a 4FEA0212 		lsl	r2, r2, #4
 434 018e 9B18     		adds	r3, r3, r2
 435 0190 03F10803 		add	r3, r3, #8
 436 0194 4FF00502 		mov	r2, #5
 437 0198 9A71     		strb	r2, [r3, #6]
 169:../src/spark_wiring.c **** 		break;
 438              		.loc 1 169 0
 439 019a 00E0     		b	.L14
 440              	.L16:
 170:../src/spark_wiring.c **** 
 171:../src/spark_wiring.c **** 	default:
 172:../src/spark_wiring.c **** 		break;
 441              		.loc 1 172 0
 442 019c 00BF     		nop
 443              	.L14:
 173:../src/spark_wiring.c **** 	}
 174:../src/spark_wiring.c **** 
 175:../src/spark_wiring.c **** 	GPIO_Init(gpio_port, &GPIO_InitStructure);
 444              		.loc 1 175 0
 445 019e 07F10C03 		add	r3, r7, #12
 446 01a2 7869     		ldr	r0, [r7, #20]
 447 01a4 1946     		mov	r1, r3
 448 01a6 FFF7FEFF 		bl	GPIO_Init
 449              	.L1:
 176:../src/spark_wiring.c **** }
 450              		.loc 1 176 0
 451 01aa 07F11807 		add	r7, r7, #24
 452 01ae BD46     		mov	sp, r7
 453 01b0 80BD     		pop	{r7, pc}
 454              		.cfi_endproc
 455              	.LFE56:
 457 01b2 00BF     		.section	.text.digitalWrite,"ax",%progbits
 458              		.align	2
 459              		.global	digitalWrite
 460              		.thumb
 461              		.thumb_func
 463              	digitalWrite:
 464              	.LFB57:
 177:../src/spark_wiring.c **** 
 178:../src/spark_wiring.c **** /*
 179:../src/spark_wiring.c ****  * @brief Sets a GPIO pin to HIGH or LOW.
 180:../src/spark_wiring.c ****  */
 181:../src/spark_wiring.c **** void digitalWrite(uint16_t pin, uint8_t value)
 182:../src/spark_wiring.c **** {
 465              		.loc 1 182 0
 466              		.cfi_startproc
 467              		@ args = 0, pretend = 0, frame = 8
 468              		@ frame_needed = 1, uses_anonymous_args = 0
 469 0000 80B5     		push	{r7, lr}
 470              	.LCFI3:
 471              		.cfi_def_cfa_offset 8
 472              		.cfi_offset 7, -8
 473              		.cfi_offset 14, -4
 474 0002 82B0     		sub	sp, sp, #8
 475              	.LCFI4:
 476              		.cfi_def_cfa_offset 16
 477 0004 00AF     		add	r7, sp, #0
 478              	.LCFI5:
 479              		.cfi_def_cfa_register 7
 480 0006 0246     		mov	r2, r0
 481 0008 0B46     		mov	r3, r1
 482 000a FA80     		strh	r2, [r7, #6]	@ movhi
 483 000c 7B71     		strb	r3, [r7, #5]
 183:../src/spark_wiring.c **** 	if (pin >= TOTAL_PINS || PIN_MAP[pin].pin_mode == INPUT
 484              		.loc 1 183 0
 485 000e FB88     		ldrh	r3, [r7, #6]
 486 0010 142B     		cmp	r3, #20
 487 0012 00F29080 		bhi	.L25
 488              		.loc 1 183 0 is_stmt 0 discriminator 1
 489 0016 FA88     		ldrh	r2, [r7, #6]
 490 0018 40F20003 		movw	r3, #:lower16:PIN_MAP
 491 001c C0F20003 		movt	r3, #:upper16:PIN_MAP
 492 0020 4FEA0212 		lsl	r2, r2, #4
 493 0024 9B18     		adds	r3, r3, r2
 494 0026 03F10803 		add	r3, r3, #8
 495 002a 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 496 002c 012B     		cmp	r3, #1
 497 002e 00F08280 		beq	.L25
 184:../src/spark_wiring.c **** 	|| PIN_MAP[pin].pin_mode == INPUT_PULLUP|| PIN_MAP[pin].pin_mode == INPUT_PULLDOWN
 498              		.loc 1 184 0 is_stmt 1
 499 0032 FA88     		ldrh	r2, [r7, #6]
 500 0034 40F20003 		movw	r3, #:lower16:PIN_MAP
 501 0038 C0F20003 		movt	r3, #:upper16:PIN_MAP
 502 003c 4FEA0212 		lsl	r2, r2, #4
 503 0040 9B18     		adds	r3, r3, r2
 504 0042 03F10803 		add	r3, r3, #8
 505 0046 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 506 0048 022B     		cmp	r3, #2
 507 004a 74D0     		beq	.L25
 508              		.loc 1 184 0 is_stmt 0 discriminator 1
 509 004c FA88     		ldrh	r2, [r7, #6]
 510 004e 40F20003 		movw	r3, #:lower16:PIN_MAP
 511 0052 C0F20003 		movt	r3, #:upper16:PIN_MAP
 512 0056 4FEA0212 		lsl	r2, r2, #4
 513 005a 9B18     		adds	r3, r3, r2
 514 005c 03F10803 		add	r3, r3, #8
 515 0060 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 516 0062 032B     		cmp	r3, #3
 517 0064 67D0     		beq	.L25
 185:../src/spark_wiring.c **** 	|| PIN_MAP[pin].pin_mode == AN_INPUT || PIN_MAP[pin].pin_mode == NONE)
 518              		.loc 1 185 0 is_stmt 1
 519 0066 FA88     		ldrh	r2, [r7, #6]
 520 0068 40F20003 		movw	r3, #:lower16:PIN_MAP
 521 006c C0F20003 		movt	r3, #:upper16:PIN_MAP
 522 0070 4FEA0212 		lsl	r2, r2, #4
 523 0074 9B18     		adds	r3, r3, r2
 524 0076 03F10803 		add	r3, r3, #8
 525 007a 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 526 007c 052B     		cmp	r3, #5
 527 007e 5AD0     		beq	.L25
 528              		.loc 1 185 0 is_stmt 0 discriminator 1
 529 0080 FA88     		ldrh	r2, [r7, #6]
 530 0082 40F20003 		movw	r3, #:lower16:PIN_MAP
 531 0086 C0F20003 		movt	r3, #:upper16:PIN_MAP
 532 008a 4FEA0212 		lsl	r2, r2, #4
 533 008e 9B18     		adds	r3, r3, r2
 534 0090 03F10803 		add	r3, r3, #8
 535 0094 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 536 0096 FF2B     		cmp	r3, #255
 537 0098 4DD0     		beq	.L25
 538              	.L19:
 186:../src/spark_wiring.c **** 	{
 187:../src/spark_wiring.c **** 		return;
 188:../src/spark_wiring.c **** 	}
 189:../src/spark_wiring.c **** 
 190:../src/spark_wiring.c **** 	// Serial1 safety check
 191:../src/spark_wiring.c **** 	if (serial1_enabled == true && (pin == RX || pin == TX))
 539              		.loc 1 191 0 is_stmt 1
 540 009a 40F20003 		movw	r3, #:lower16:serial1_enabled
 541 009e C0F20003 		movt	r3, #:upper16:serial1_enabled
 542 00a2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 543 00a4 012B     		cmp	r3, #1
 544 00a6 05D1     		bne	.L21
 545              		.loc 1 191 0 is_stmt 0 discriminator 1
 546 00a8 FB88     		ldrh	r3, [r7, #6]
 547 00aa 122B     		cmp	r3, #18
 548 00ac 45D0     		beq	.L26
 549 00ae FB88     		ldrh	r3, [r7, #6]
 550 00b0 132B     		cmp	r3, #19
 551 00b2 42D0     		beq	.L26
 552              	.L21:
 192:../src/spark_wiring.c **** 	{
 193:../src/spark_wiring.c **** 		return;
 194:../src/spark_wiring.c **** 	}
 195:../src/spark_wiring.c **** 
 196:../src/spark_wiring.c **** 	//If the pin is used by analogWrite, we need to change the mode
 197:../src/spark_wiring.c **** 	if(PIN_MAP[pin].pin_mode == AF_OUTPUT)
 553              		.loc 1 197 0 is_stmt 1
 554 00b4 FA88     		ldrh	r2, [r7, #6]
 555 00b6 40F20003 		movw	r3, #:lower16:PIN_MAP
 556 00ba C0F20003 		movt	r3, #:upper16:PIN_MAP
 557 00be 4FEA0212 		lsl	r2, r2, #4
 558 00c2 9B18     		adds	r3, r3, r2
 559 00c4 03F10803 		add	r3, r3, #8
 560 00c8 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 561 00ca 042B     		cmp	r3, #4
 562 00cc 05D1     		bne	.L23
 198:../src/spark_wiring.c **** 	{
 199:../src/spark_wiring.c **** 		pinMode(pin, OUTPUT);
 563              		.loc 1 199 0
 564 00ce FB88     		ldrh	r3, [r7, #6]
 565 00d0 1846     		mov	r0, r3
 566 00d2 4FF00001 		mov	r1, #0
 567 00d6 FFF7FEFF 		bl	pinMode
 568              	.L23:
 200:../src/spark_wiring.c **** 	}
 201:../src/spark_wiring.c **** 
 202:../src/spark_wiring.c **** 	if (value == HIGH)
 569              		.loc 1 202 0
 570 00da 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 571 00dc 012B     		cmp	r3, #1
 572 00de 13D1     		bne	.L24
 203:../src/spark_wiring.c **** 	{
 204:../src/spark_wiring.c **** 		PIN_MAP[pin].gpio_peripheral->BSRR = PIN_MAP[pin].gpio_pin;
 573              		.loc 1 204 0
 574 00e0 FA88     		ldrh	r2, [r7, #6]
 575 00e2 40F20003 		movw	r3, #:lower16:PIN_MAP
 576 00e6 C0F20003 		movt	r3, #:upper16:PIN_MAP
 577 00ea 4FEA0212 		lsl	r2, r2, #4
 578 00ee 9B18     		adds	r3, r3, r2
 579 00f0 1A68     		ldr	r2, [r3, #0]
 580 00f2 F988     		ldrh	r1, [r7, #6]
 581 00f4 40F20003 		movw	r3, #:lower16:PIN_MAP
 582 00f8 C0F20003 		movt	r3, #:upper16:PIN_MAP
 583 00fc 4FEA0111 		lsl	r1, r1, #4
 584 0100 5B18     		adds	r3, r3, r1
 585 0102 9B88     		ldrh	r3, [r3, #4]
 586 0104 1361     		str	r3, [r2, #16]
 587 0106 19E0     		b	.L17
 588              	.L24:
 205:../src/spark_wiring.c **** 	}
 206:../src/spark_wiring.c **** 	else if (value == LOW)
 589              		.loc 1 206 0
 590 0108 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 591 010a 002B     		cmp	r3, #0
 592 010c 16D1     		bne	.L17
 207:../src/spark_wiring.c **** 	{
 208:../src/spark_wiring.c **** 		PIN_MAP[pin].gpio_peripheral->BRR = PIN_MAP[pin].gpio_pin;
 593              		.loc 1 208 0
 594 010e FA88     		ldrh	r2, [r7, #6]
 595 0110 40F20003 		movw	r3, #:lower16:PIN_MAP
 596 0114 C0F20003 		movt	r3, #:upper16:PIN_MAP
 597 0118 4FEA0212 		lsl	r2, r2, #4
 598 011c 9B18     		adds	r3, r3, r2
 599 011e 1A68     		ldr	r2, [r3, #0]
 600 0120 F988     		ldrh	r1, [r7, #6]
 601 0122 40F20003 		movw	r3, #:lower16:PIN_MAP
 602 0126 C0F20003 		movt	r3, #:upper16:PIN_MAP
 603 012a 4FEA0111 		lsl	r1, r1, #4
 604 012e 5B18     		adds	r3, r3, r1
 605 0130 9B88     		ldrh	r3, [r3, #4]
 606 0132 5361     		str	r3, [r2, #20]
 607 0134 02E0     		b	.L17
 608              	.L25:
 187:../src/spark_wiring.c **** 		return;
 609              		.loc 1 187 0
 610 0136 00BF     		nop
 611 0138 00E0     		b	.L17
 612              	.L26:
 193:../src/spark_wiring.c **** 		return;
 613              		.loc 1 193 0
 614 013a 00BF     		nop
 615              	.L17:
 209:../src/spark_wiring.c **** 	}
 210:../src/spark_wiring.c **** }
 616              		.loc 1 210 0
 617 013c 07F10807 		add	r7, r7, #8
 618 0140 BD46     		mov	sp, r7
 619 0142 80BD     		pop	{r7, pc}
 620              		.cfi_endproc
 621              	.LFE57:
 623              		.section	.text.digitalRead,"ax",%progbits
 624              		.align	2
 625              		.global	digitalRead
 626              		.thumb
 627              		.thumb_func
 629              	digitalRead:
 630              	.LFB58:
 211:../src/spark_wiring.c **** 
 212:../src/spark_wiring.c **** /*
 213:../src/spark_wiring.c ****  * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 214:../src/spark_wiring.c ****  */
 215:../src/spark_wiring.c **** int32_t digitalRead(uint16_t pin)
 216:../src/spark_wiring.c **** {
 631              		.loc 1 216 0
 632              		.cfi_startproc
 633              		@ args = 0, pretend = 0, frame = 8
 634              		@ frame_needed = 1, uses_anonymous_args = 0
 635 0000 80B5     		push	{r7, lr}
 636              	.LCFI6:
 637              		.cfi_def_cfa_offset 8
 638              		.cfi_offset 7, -8
 639              		.cfi_offset 14, -4
 640 0002 82B0     		sub	sp, sp, #8
 641              	.LCFI7:
 642              		.cfi_def_cfa_offset 16
 643 0004 00AF     		add	r7, sp, #0
 644              	.LCFI8:
 645              		.cfi_def_cfa_register 7
 646 0006 0346     		mov	r3, r0
 647 0008 FB80     		strh	r3, [r7, #6]	@ movhi
 217:../src/spark_wiring.c **** 	if (pin >= TOTAL_PINS || PIN_MAP[pin].pin_mode == OUTPUT || PIN_MAP[pin].pin_mode == NONE)
 648              		.loc 1 217 0
 649 000a FB88     		ldrh	r3, [r7, #6]
 650 000c 142B     		cmp	r3, #20
 651 000e 19D8     		bhi	.L28
 652              		.loc 1 217 0 is_stmt 0 discriminator 1
 653 0010 FA88     		ldrh	r2, [r7, #6]
 654 0012 40F20003 		movw	r3, #:lower16:PIN_MAP
 655 0016 C0F20003 		movt	r3, #:upper16:PIN_MAP
 656 001a 4FEA0212 		lsl	r2, r2, #4
 657 001e 9B18     		adds	r3, r3, r2
 658 0020 03F10803 		add	r3, r3, #8
 659 0024 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 660 0026 002B     		cmp	r3, #0
 661 0028 0CD0     		beq	.L28
 662 002a FA88     		ldrh	r2, [r7, #6]
 663 002c 40F20003 		movw	r3, #:lower16:PIN_MAP
 664 0030 C0F20003 		movt	r3, #:upper16:PIN_MAP
 665 0034 4FEA0212 		lsl	r2, r2, #4
 666 0038 9B18     		adds	r3, r3, r2
 667 003a 03F10803 		add	r3, r3, #8
 668 003e 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 669 0040 FF2B     		cmp	r3, #255
 670 0042 02D1     		bne	.L29
 671              	.L28:
 218:../src/spark_wiring.c **** 	{
 219:../src/spark_wiring.c **** 		return -1;
 672              		.loc 1 219 0 is_stmt 1
 673 0044 4FF0FF33 		mov	r3, #-1
 674 0048 4EE0     		b	.L30
 675              	.L29:
 220:../src/spark_wiring.c **** 	}
 221:../src/spark_wiring.c **** 
 222:../src/spark_wiring.c **** 	// Serial1 safety check
 223:../src/spark_wiring.c **** 	if (serial1_enabled == true && (pin == RX || pin == TX))
 676              		.loc 1 223 0
 677 004a 40F20003 		movw	r3, #:lower16:serial1_enabled
 678 004e C0F20003 		movt	r3, #:upper16:serial1_enabled
 679 0052 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 680 0054 012B     		cmp	r3, #1
 681 0056 08D1     		bne	.L31
 682              		.loc 1 223 0 is_stmt 0 discriminator 1
 683 0058 FB88     		ldrh	r3, [r7, #6]
 684 005a 122B     		cmp	r3, #18
 685 005c 02D0     		beq	.L32
 686 005e FB88     		ldrh	r3, [r7, #6]
 687 0060 132B     		cmp	r3, #19
 688 0062 02D1     		bne	.L31
 689              	.L32:
 224:../src/spark_wiring.c **** 	{
 225:../src/spark_wiring.c **** 		return -1;
 690              		.loc 1 225 0 is_stmt 1
 691 0064 4FF0FF33 		mov	r3, #-1
 692 0068 3EE0     		b	.L30
 693              	.L31:
 226:../src/spark_wiring.c **** 	}
 227:../src/spark_wiring.c **** 
 228:../src/spark_wiring.c **** 	if(PIN_MAP[pin].pin_mode == AN_INPUT)
 694              		.loc 1 228 0
 695 006a FA88     		ldrh	r2, [r7, #6]
 696 006c 40F20003 		movw	r3, #:lower16:PIN_MAP
 697 0070 C0F20003 		movt	r3, #:upper16:PIN_MAP
 698 0074 4FEA0212 		lsl	r2, r2, #4
 699 0078 9B18     		adds	r3, r3, r2
 700 007a 03F10803 		add	r3, r3, #8
 701 007e 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 702 0080 052B     		cmp	r3, #5
 703 0082 1AD1     		bne	.L33
 229:../src/spark_wiring.c **** 	{
 230:../src/spark_wiring.c **** 		if(digitalPinModeSaved == OUTPUT || digitalPinModeSaved == NONE)
 704              		.loc 1 230 0
 705 0084 40F20003 		movw	r3, #:lower16:digitalPinModeSaved
 706 0088 C0F20003 		movt	r3, #:upper16:digitalPinModeSaved
 707 008c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 708 008e 002B     		cmp	r3, #0
 709 0090 06D0     		beq	.L34
 710              		.loc 1 230 0 is_stmt 0 discriminator 1
 711 0092 40F20003 		movw	r3, #:lower16:digitalPinModeSaved
 712 0096 C0F20003 		movt	r3, #:upper16:digitalPinModeSaved
 713 009a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 714 009c FF2B     		cmp	r3, #255
 715 009e 02D1     		bne	.L35
 716              	.L34:
 231:../src/spark_wiring.c **** 		{
 232:../src/spark_wiring.c **** 			return -1;
 717              		.loc 1 232 0 is_stmt 1
 718 00a0 4FF0FF33 		mov	r3, #-1
 719 00a4 20E0     		b	.L30
 720              	.L35:
 233:../src/spark_wiring.c **** 		}
 234:../src/spark_wiring.c **** 		else
 235:../src/spark_wiring.c **** 		{
 236:../src/spark_wiring.c **** 			//Restore the PinMode after calling analogRead on same pin earlier
 237:../src/spark_wiring.c **** 			pinMode(pin, digitalPinModeSaved);
 721              		.loc 1 237 0
 722 00a6 40F20003 		movw	r3, #:lower16:digitalPinModeSaved
 723 00aa C0F20003 		movt	r3, #:upper16:digitalPinModeSaved
 724 00ae 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 725 00b0 FA88     		ldrh	r2, [r7, #6]
 726 00b2 1046     		mov	r0, r2
 727 00b4 1946     		mov	r1, r3
 728 00b6 FFF7FEFF 		bl	pinMode
 729              	.L33:
 238:../src/spark_wiring.c **** 		}
 239:../src/spark_wiring.c **** 	}
 240:../src/spark_wiring.c **** 
 241:../src/spark_wiring.c **** 	return GPIO_ReadInputDataBit(PIN_MAP[pin].gpio_peripheral, PIN_MAP[pin].gpio_pin);
 730              		.loc 1 241 0
 731 00ba FA88     		ldrh	r2, [r7, #6]
 732 00bc 40F20003 		movw	r3, #:lower16:PIN_MAP
 733 00c0 C0F20003 		movt	r3, #:upper16:PIN_MAP
 734 00c4 4FEA0212 		lsl	r2, r2, #4
 735 00c8 9B18     		adds	r3, r3, r2
 736 00ca 1A68     		ldr	r2, [r3, #0]
 737 00cc F988     		ldrh	r1, [r7, #6]
 738 00ce 40F20003 		movw	r3, #:lower16:PIN_MAP
 739 00d2 C0F20003 		movt	r3, #:upper16:PIN_MAP
 740 00d6 4FEA0111 		lsl	r1, r1, #4
 741 00da 5B18     		adds	r3, r3, r1
 742 00dc 9B88     		ldrh	r3, [r3, #4]
 743 00de 1046     		mov	r0, r2
 744 00e0 1946     		mov	r1, r3
 745 00e2 FFF7FEFF 		bl	GPIO_ReadInputDataBit
 746 00e6 0346     		mov	r3, r0
 747              	.L30:
 242:../src/spark_wiring.c **** }
 748              		.loc 1 242 0
 749 00e8 1846     		mov	r0, r3
 750 00ea 07F10807 		add	r7, r7, #8
 751 00ee BD46     		mov	sp, r7
 752 00f0 80BD     		pop	{r7, pc}
 753              		.cfi_endproc
 754              	.LFE58:
 756 00f2 00BF     		.section	.text.ADCInit,"ax",%progbits
 757              		.align	2
 758              		.global	ADCInit
 759              		.thumb
 760              		.thumb_func
 762              	ADCInit:
 763              	.LFB59:
 243:../src/spark_wiring.c **** 
 244:../src/spark_wiring.c **** /*
 245:../src/spark_wiring.c ****  * @brief Initialize the ADC peripheral.
 246:../src/spark_wiring.c ****  */
 247:../src/spark_wiring.c **** void ADCInit()
 248:../src/spark_wiring.c **** {
 764              		.loc 1 248 0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 24
 767              		@ frame_needed = 1, uses_anonymous_args = 0
 768 0000 80B5     		push	{r7, lr}
 769              	.LCFI9:
 770              		.cfi_def_cfa_offset 8
 771              		.cfi_offset 7, -8
 772              		.cfi_offset 14, -4
 773 0002 86B0     		sub	sp, sp, #24
 774              	.LCFI10:
 775              		.cfi_def_cfa_offset 32
 776 0004 00AF     		add	r7, sp, #0
 777              	.LCFI11:
 778              		.cfi_def_cfa_register 7
 249:../src/spark_wiring.c **** 
 250:../src/spark_wiring.c **** 	ADC_InitTypeDef ADC_InitStructure;
 251:../src/spark_wiring.c **** 
 252:../src/spark_wiring.c **** 	// ADCCLK = PCLK2/4
 253:../src/spark_wiring.c **** 	// RCC_ADCCLKConfig(RCC_PCLK2_Div4);
 254:../src/spark_wiring.c **** 	// ADCCLK = PCLK2/6 = 72/6 = 12MHz
 255:../src/spark_wiring.c **** 	RCC_ADCCLKConfig(RCC_PCLK2_Div6);
 779              		.loc 1 255 0
 780 0006 4FF40040 		mov	r0, #32768
 781 000a FFF7FEFF 		bl	RCC_ADCCLKConfig
 256:../src/spark_wiring.c **** 
 257:../src/spark_wiring.c **** 	// Enable ADC1 clock
 258:../src/spark_wiring.c **** 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 782              		.loc 1 258 0
 783 000e 4FF40070 		mov	r0, #512
 784 0012 4FF00101 		mov	r1, #1
 785 0016 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 259:../src/spark_wiring.c **** 
 260:../src/spark_wiring.c **** 	// Put everything back to power-on defaults
 261:../src/spark_wiring.c **** 	ADC_DeInit(ADC1);
 786              		.loc 1 261 0
 787 001a 4FF41050 		mov	r0, #9216
 788 001e C4F20100 		movt	r0, 16385
 789 0022 FFF7FEFF 		bl	ADC_DeInit
 262:../src/spark_wiring.c **** 
 263:../src/spark_wiring.c **** 	// ADC1 Configuration
 264:../src/spark_wiring.c **** 	// ADC1 operate independently
 265:../src/spark_wiring.c **** 	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
 790              		.loc 1 265 0
 791 0026 4FF00003 		mov	r3, #0
 792 002a 7B60     		str	r3, [r7, #4]
 266:../src/spark_wiring.c **** 	// Disable the scan conversion so we do one at a time
 267:../src/spark_wiring.c **** 	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
 793              		.loc 1 267 0
 794 002c 4FF00003 		mov	r3, #0
 795 0030 3B72     		strb	r3, [r7, #8]
 268:../src/spark_wiring.c **** 	// Don't do continuous conversions - do them on demand
 269:../src/spark_wiring.c **** 	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
 796              		.loc 1 269 0
 797 0032 4FF00003 		mov	r3, #0
 798 0036 7B72     		strb	r3, [r7, #9]
 270:../src/spark_wiring.c **** 	// Start conversion by software, not an external trigger
 271:../src/spark_wiring.c **** 	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
 799              		.loc 1 271 0
 800 0038 4FF46023 		mov	r3, #917504
 801 003c FB60     		str	r3, [r7, #12]
 272:../src/spark_wiring.c **** 	// Conversions are 12 bit - put them in the lower 12 bits of the result
 273:../src/spark_wiring.c **** 	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 802              		.loc 1 273 0
 803 003e 4FF00003 		mov	r3, #0
 804 0042 3B61     		str	r3, [r7, #16]
 274:../src/spark_wiring.c **** 	// Say how many channels would be used by the sequencer
 275:../src/spark_wiring.c **** 	ADC_InitStructure.ADC_NbrOfChannel = 1;
 805              		.loc 1 275 0
 806 0044 4FF00103 		mov	r3, #1
 807 0048 3B75     		strb	r3, [r7, #20]
 276:../src/spark_wiring.c **** 	// Now do the setup
 277:../src/spark_wiring.c **** 	ADC_Init(ADC1, &ADC_InitStructure);
 808              		.loc 1 277 0
 809 004a 07F10403 		add	r3, r7, #4
 810 004e 4FF41050 		mov	r0, #9216
 811 0052 C4F20100 		movt	r0, 16385
 812 0056 1946     		mov	r1, r3
 813 0058 FFF7FEFF 		bl	ADC_Init
 278:../src/spark_wiring.c **** 
 279:../src/spark_wiring.c **** 	// Enable ADC1
 280:../src/spark_wiring.c **** 	ADC_Cmd(ADC1, ENABLE);
 814              		.loc 1 280 0
 815 005c 4FF41050 		mov	r0, #9216
 816 0060 C4F20100 		movt	r0, 16385
 817 0064 4FF00101 		mov	r1, #1
 818 0068 FFF7FEFF 		bl	ADC_Cmd
 281:../src/spark_wiring.c **** 
 282:../src/spark_wiring.c **** 	// Enable ADC1 reset calibration register
 283:../src/spark_wiring.c **** 	ADC_ResetCalibration(ADC1);
 819              		.loc 1 283 0
 820 006c 4FF41050 		mov	r0, #9216
 821 0070 C4F20100 		movt	r0, 16385
 822 0074 FFF7FEFF 		bl	ADC_ResetCalibration
 284:../src/spark_wiring.c **** 
 285:../src/spark_wiring.c **** 	// Check the end of ADC1 reset calibration register
 286:../src/spark_wiring.c **** 	while(ADC_GetResetCalibrationStatus(ADC1));
 823              		.loc 1 286 0
 824 0078 00BF     		nop
 825              	.L37:
 826              		.loc 1 286 0 is_stmt 0 discriminator 1
 827 007a 4FF41050 		mov	r0, #9216
 828 007e C4F20100 		movt	r0, 16385
 829 0082 FFF7FEFF 		bl	ADC_GetResetCalibrationStatus
 830 0086 0346     		mov	r3, r0
 831 0088 002B     		cmp	r3, #0
 832 008a F6D1     		bne	.L37
 287:../src/spark_wiring.c **** 
 288:../src/spark_wiring.c **** 	// Start ADC1 calibration
 289:../src/spark_wiring.c **** 	ADC_StartCalibration(ADC1);
 833              		.loc 1 289 0 is_stmt 1
 834 008c 4FF41050 		mov	r0, #9216
 835 0090 C4F20100 		movt	r0, 16385
 836 0094 FFF7FEFF 		bl	ADC_StartCalibration
 290:../src/spark_wiring.c **** 
 291:../src/spark_wiring.c **** 	// Check the end of ADC1 calibration
 292:../src/spark_wiring.c **** 	while(ADC_GetCalibrationStatus(ADC1));
 837              		.loc 1 292 0
 838 0098 00BF     		nop
 839              	.L38:
 840              		.loc 1 292 0 is_stmt 0 discriminator 1
 841 009a 4FF41050 		mov	r0, #9216
 842 009e C4F20100 		movt	r0, 16385
 843 00a2 FFF7FEFF 		bl	ADC_GetCalibrationStatus
 844 00a6 0346     		mov	r3, r0
 845 00a8 002B     		cmp	r3, #0
 846 00aa F6D1     		bne	.L38
 293:../src/spark_wiring.c **** }
 847              		.loc 1 293 0 is_stmt 1
 848 00ac 07F11807 		add	r7, r7, #24
 849 00b0 BD46     		mov	sp, r7
 850 00b2 80BD     		pop	{r7, pc}
 851              		.cfi_endproc
 852              	.LFE59:
 854              		.section	.text.analogRead,"ax",%progbits
 855              		.align	2
 856              		.global	analogRead
 857              		.thumb
 858              		.thumb_func
 860              	analogRead:
 861              	.LFB60:
 294:../src/spark_wiring.c **** 
 295:../src/spark_wiring.c **** /*
 296:../src/spark_wiring.c ****  * @brief Read the analog value of a pin.
 297:../src/spark_wiring.c ****  * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 298:../src/spark_wiring.c ****  * Note: ADC is 12-bit. Currently it returns 0-4096
 299:../src/spark_wiring.c ****  */
 300:../src/spark_wiring.c **** int32_t analogRead(uint16_t pin)
 301:../src/spark_wiring.c **** {
 862              		.loc 1 301 0
 863              		.cfi_startproc
 864              		@ args = 0, pretend = 0, frame = 8
 865              		@ frame_needed = 1, uses_anonymous_args = 0
 866 0000 80B5     		push	{r7, lr}
 867              	.LCFI12:
 868              		.cfi_def_cfa_offset 8
 869              		.cfi_offset 7, -8
 870              		.cfi_offset 14, -4
 871 0002 82B0     		sub	sp, sp, #8
 872              	.LCFI13:
 873              		.cfi_def_cfa_offset 16
 874 0004 00AF     		add	r7, sp, #0
 875              	.LCFI14:
 876              		.cfi_def_cfa_register 7
 877 0006 0346     		mov	r3, r0
 878 0008 FB80     		strh	r3, [r7, #6]	@ movhi
 302:../src/spark_wiring.c **** 	// Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
 303:../src/spark_wiring.c **** 	if (pin < FIRST_ANALOG_PIN)
 879              		.loc 1 303 0
 880 000a FB88     		ldrh	r3, [r7, #6]
 881 000c 092B     		cmp	r3, #9
 882 000e 03D8     		bhi	.L40
 304:../src/spark_wiring.c **** 	{
 305:../src/spark_wiring.c **** 		pin = pin + FIRST_ANALOG_PIN;
 883              		.loc 1 305 0
 884 0010 FB88     		ldrh	r3, [r7, #6]	@ movhi
 885 0012 03F10A03 		add	r3, r3, #10
 886 0016 FB80     		strh	r3, [r7, #6]	@ movhi
 887              	.L40:
 306:../src/spark_wiring.c **** 	}
 307:../src/spark_wiring.c **** 
 308:../src/spark_wiring.c **** 	// Serial1 safety check
 309:../src/spark_wiring.c **** 	if (serial1_enabled == true && (pin == RX || pin == TX))
 888              		.loc 1 309 0
 889 0018 40F20003 		movw	r3, #:lower16:serial1_enabled
 890 001c C0F20003 		movt	r3, #:upper16:serial1_enabled
 891 0020 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 892 0022 012B     		cmp	r3, #1
 893 0024 08D1     		bne	.L41
 894              		.loc 1 309 0 is_stmt 0 discriminator 1
 895 0026 FB88     		ldrh	r3, [r7, #6]
 896 0028 122B     		cmp	r3, #18
 897 002a 02D0     		beq	.L42
 898 002c FB88     		ldrh	r3, [r7, #6]
 899 002e 132B     		cmp	r3, #19
 900 0030 02D1     		bne	.L41
 901              	.L42:
 310:../src/spark_wiring.c **** 	{
 311:../src/spark_wiring.c **** 		return -1;
 902              		.loc 1 311 0 is_stmt 1
 903 0032 4FF0FF33 		mov	r3, #-1
 904 0036 93E0     		b	.L43
 905              	.L41:
 312:../src/spark_wiring.c **** 	}
 313:../src/spark_wiring.c **** 
 314:../src/spark_wiring.c **** 	if (pin >= TOTAL_PINS || PIN_MAP[pin].adc_channel == NONE )
 906              		.loc 1 314 0
 907 0038 FB88     		ldrh	r3, [r7, #6]
 908 003a 142B     		cmp	r3, #20
 909 003c 0AD8     		bhi	.L44
 910              		.loc 1 314 0 is_stmt 0 discriminator 1
 911 003e FA88     		ldrh	r2, [r7, #6]
 912 0040 40F20003 		movw	r3, #:lower16:PIN_MAP
 913 0044 C0F20003 		movt	r3, #:upper16:PIN_MAP
 914 0048 4FEA0212 		lsl	r2, r2, #4
 915 004c 9B18     		adds	r3, r3, r2
 916 004e 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 917 0050 FF2B     		cmp	r3, #255
 918 0052 02D1     		bne	.L45
 919              	.L44:
 315:../src/spark_wiring.c **** 	{
 316:../src/spark_wiring.c **** 		return -1;
 920              		.loc 1 316 0 is_stmt 1
 921 0054 4FF0FF33 		mov	r3, #-1
 922 0058 82E0     		b	.L43
 923              	.L45:
 317:../src/spark_wiring.c **** 	}
 318:../src/spark_wiring.c **** 
 319:../src/spark_wiring.c **** 	if (adcChannelConfigured != PIN_MAP[pin].adc_channel)
 924              		.loc 1 319 0
 925 005a FA88     		ldrh	r2, [r7, #6]
 926 005c 40F20003 		movw	r3, #:lower16:PIN_MAP
 927 0060 C0F20003 		movt	r3, #:upper16:PIN_MAP
 928 0064 4FEA0212 		lsl	r2, r2, #4
 929 0068 9B18     		adds	r3, r3, r2
 930 006a 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 931 006c 40F20003 		movw	r3, #:lower16:adcChannelConfigured
 932 0070 C0F20003 		movt	r3, #:upper16:adcChannelConfigured
 933 0074 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 934 0076 9A42     		cmp	r2, r3
 935 0078 15D0     		beq	.L46
 320:../src/spark_wiring.c **** 	{
 321:../src/spark_wiring.c **** 		digitalPinModeSaved = PIN_MAP[pin].pin_mode;
 936              		.loc 1 321 0
 937 007a FA88     		ldrh	r2, [r7, #6]
 938 007c 40F20003 		movw	r3, #:lower16:PIN_MAP
 939 0080 C0F20003 		movt	r3, #:upper16:PIN_MAP
 940 0084 4FEA0212 		lsl	r2, r2, #4
 941 0088 9B18     		adds	r3, r3, r2
 942 008a 03F10803 		add	r3, r3, #8
 943 008e 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 944 0090 40F20003 		movw	r3, #:lower16:digitalPinModeSaved
 945 0094 C0F20003 		movt	r3, #:upper16:digitalPinModeSaved
 946 0098 1A70     		strb	r2, [r3, #0]
 322:../src/spark_wiring.c **** 		pinMode(pin, AN_INPUT);
 947              		.loc 1 322 0
 948 009a FB88     		ldrh	r3, [r7, #6]
 949 009c 1846     		mov	r0, r3
 950 009e 4FF00501 		mov	r1, #5
 951 00a2 FFF7FEFF 		bl	pinMode
 952              	.L46:
 323:../src/spark_wiring.c **** 	}
 324:../src/spark_wiring.c **** 
 325:../src/spark_wiring.c **** 	if (adcInitFirstTime == true)
 953              		.loc 1 325 0
 954 00a6 40F20003 		movw	r3, #:lower16:adcInitFirstTime
 955 00aa C0F20003 		movt	r3, #:upper16:adcInitFirstTime
 956 00ae 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 957 00b0 012B     		cmp	r3, #1
 958 00b2 08D1     		bne	.L47
 326:../src/spark_wiring.c **** 	{
 327:../src/spark_wiring.c **** 		ADCInit();
 959              		.loc 1 327 0
 960 00b4 FFF7FEFF 		bl	ADCInit
 328:../src/spark_wiring.c **** 		adcInitFirstTime = false;
 961              		.loc 1 328 0
 962 00b8 40F20003 		movw	r3, #:lower16:adcInitFirstTime
 963 00bc C0F20003 		movt	r3, #:upper16:adcInitFirstTime
 964 00c0 4FF00002 		mov	r2, #0
 965 00c4 1A70     		strb	r2, [r3, #0]
 966              	.L47:
 329:../src/spark_wiring.c **** 	}
 330:../src/spark_wiring.c **** 
 331:../src/spark_wiring.c **** 	if (adcChannelConfigured != PIN_MAP[pin].adc_channel)
 967              		.loc 1 331 0
 968 00c6 FA88     		ldrh	r2, [r7, #6]
 969 00c8 40F20003 		movw	r3, #:lower16:PIN_MAP
 970 00cc C0F20003 		movt	r3, #:upper16:PIN_MAP
 971 00d0 4FEA0212 		lsl	r2, r2, #4
 972 00d4 9B18     		adds	r3, r3, r2
 973 00d6 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 974 00d8 40F20003 		movw	r3, #:lower16:adcChannelConfigured
 975 00dc C0F20003 		movt	r3, #:upper16:adcChannelConfigured
 976 00e0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 977 00e2 9A42     		cmp	r2, r3
 978 00e4 21D0     		beq	.L48
 332:../src/spark_wiring.c **** 	{
 333:../src/spark_wiring.c **** 		ADC_RegularChannelConfig(ADC1, PIN_MAP[pin].adc_channel, 1, ADC_SAMPLING_TIME);
 979              		.loc 1 333 0
 980 00e6 FA88     		ldrh	r2, [r7, #6]
 981 00e8 40F20003 		movw	r3, #:lower16:PIN_MAP
 982 00ec C0F20003 		movt	r3, #:upper16:PIN_MAP
 983 00f0 4FEA0212 		lsl	r2, r2, #4
 984 00f4 9B18     		adds	r3, r3, r2
 985 00f6 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 986 00f8 4FF41050 		mov	r0, #9216
 987 00fc C4F20100 		movt	r0, 16385
 988 0100 1946     		mov	r1, r3
 989 0102 4FF00102 		mov	r2, #1
 990 0106 4FF00003 		mov	r3, #0
 991 010a FFF7FEFF 		bl	ADC_RegularChannelConfig
 334:../src/spark_wiring.c **** 
 335:../src/spark_wiring.c **** 		adcChannelConfigured = PIN_MAP[pin].adc_channel;
 992              		.loc 1 335 0
 993 010e FA88     		ldrh	r2, [r7, #6]
 994 0110 40F20003 		movw	r3, #:lower16:PIN_MAP
 995 0114 C0F20003 		movt	r3, #:upper16:PIN_MAP
 996 0118 4FEA0212 		lsl	r2, r2, #4
 997 011c 9B18     		adds	r3, r3, r2
 998 011e 9A79     		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 999 0120 40F20003 		movw	r3, #:lower16:adcChannelConfigured
 1000 0124 C0F20003 		movt	r3, #:upper16:adcChannelConfigured
 1001 0128 1A70     		strb	r2, [r3, #0]
 1002              	.L48:
 336:../src/spark_wiring.c **** 	}
 337:../src/spark_wiring.c **** 
 338:../src/spark_wiring.c **** 	//Start ADC1 Software Conversion
 339:../src/spark_wiring.c **** 	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
 1003              		.loc 1 339 0
 1004 012a 4FF41050 		mov	r0, #9216
 1005 012e C4F20100 		movt	r0, 16385
 1006 0132 4FF00101 		mov	r1, #1
 1007 0136 FFF7FEFF 		bl	ADC_SoftwareStartConvCmd
 340:../src/spark_wiring.c **** 
 341:../src/spark_wiring.c **** 	// Wait until conversion completion
 342:../src/spark_wiring.c **** 	// while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
 343:../src/spark_wiring.c **** 	while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));
 1008              		.loc 1 343 0
 1009 013a 00BF     		nop
 1010              	.L49:
 1011              		.loc 1 343 0 is_stmt 0 discriminator 1
 1012 013c 4FF41050 		mov	r0, #9216
 1013 0140 C4F20100 		movt	r0, 16385
 1014 0144 4FF00201 		mov	r1, #2
 1015 0148 FFF7FEFF 		bl	ADC_GetFlagStatus
 1016 014c 0346     		mov	r3, r0
 1017 014e 002B     		cmp	r3, #0
 1018 0150 F4D0     		beq	.L49
 344:../src/spark_wiring.c **** 
 345:../src/spark_wiring.c **** 	// Get the conversion value
 346:../src/spark_wiring.c **** 	return ADC_GetConversionValue(ADC1);
 1019              		.loc 1 346 0 is_stmt 1
 1020 0152 4FF41050 		mov	r0, #9216
 1021 0156 C4F20100 		movt	r0, 16385
 1022 015a FFF7FEFF 		bl	ADC_GetConversionValue
 1023 015e 0346     		mov	r3, r0
 1024              	.L43:
 347:../src/spark_wiring.c **** }
 1025              		.loc 1 347 0
 1026 0160 1846     		mov	r0, r3
 1027 0162 07F10807 		add	r7, r7, #8
 1028 0166 BD46     		mov	sp, r7
 1029 0168 80BD     		pop	{r7, pc}
 1030              		.cfi_endproc
 1031              	.LFE60:
 1033 016a 00BF     		.section	.text.analogWrite,"ax",%progbits
 1034              		.align	2
 1035              		.global	analogWrite
 1036              		.thumb
 1037              		.thumb_func
 1039              	analogWrite:
 1040              	.LFB61:
 348:../src/spark_wiring.c **** 
 349:../src/spark_wiring.c **** /*
 350:../src/spark_wiring.c ****  * @brief Should take an integer 0-255 and create a PWM signal with a duty cycle from 0-100%.
 351:../src/spark_wiring.c ****  * TIM_PWM_FREQ is set at 500 Hz
 352:../src/spark_wiring.c ****  */
 353:../src/spark_wiring.c **** void analogWrite(uint16_t pin, uint8_t value)
 354:../src/spark_wiring.c **** {
 1041              		.loc 1 354 0
 1042              		.cfi_startproc
 1043              		@ args = 0, pretend = 0, frame = 48
 1044              		@ frame_needed = 1, uses_anonymous_args = 0
 1045 0000 80B5     		push	{r7, lr}
 1046              	.LCFI15:
 1047              		.cfi_def_cfa_offset 8
 1048              		.cfi_offset 7, -8
 1049              		.cfi_offset 14, -4
 1050 0002 8CB0     		sub	sp, sp, #48
 1051              	.LCFI16:
 1052              		.cfi_def_cfa_offset 56
 1053 0004 00AF     		add	r7, sp, #0
 1054              	.LCFI17:
 1055              		.cfi_def_cfa_register 7
 1056 0006 0246     		mov	r2, r0
 1057 0008 0B46     		mov	r3, r1
 1058 000a FA80     		strh	r2, [r7, #6]	@ movhi
 1059 000c 7B71     		strb	r3, [r7, #5]
 355:../src/spark_wiring.c **** 
 356:../src/spark_wiring.c **** 	if (pin >= TOTAL_PINS || PIN_MAP[pin].timer_peripheral == NULL)
 1060              		.loc 1 356 0
 1061 000e FB88     		ldrh	r3, [r7, #6]
 1062 0010 142B     		cmp	r3, #20
 1063 0012 00F2C181 		bhi	.L50
 1064              		.loc 1 356 0 is_stmt 0 discriminator 1
 1065 0016 FA88     		ldrh	r2, [r7, #6]
 1066 0018 40F20003 		movw	r3, #:lower16:PIN_MAP
 1067 001c C0F20003 		movt	r3, #:upper16:PIN_MAP
 1068 0020 4FEA0212 		lsl	r2, r2, #4
 1069 0024 9B18     		adds	r3, r3, r2
 1070 0026 03F10803 		add	r3, r3, #8
 1071 002a 1B68     		ldr	r3, [r3, #0]
 1072 002c 002B     		cmp	r3, #0
 1073 002e 00F0B381 		beq	.L50
 357:../src/spark_wiring.c **** 	{
 358:../src/spark_wiring.c **** 		return;
 359:../src/spark_wiring.c **** 	}
 360:../src/spark_wiring.c **** 
 361:../src/spark_wiring.c **** 	// Serial1 safety check
 362:../src/spark_wiring.c **** 	if (serial1_enabled == true && (pin == RX || pin == TX))
 1074              		.loc 1 362 0 is_stmt 1
 1075 0032 40F20003 		movw	r3, #:lower16:serial1_enabled
 1076 0036 C0F20003 		movt	r3, #:upper16:serial1_enabled
 1077 003a 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1078 003c 012B     		cmp	r3, #1
 1079 003e 07D1     		bne	.L52
 1080              		.loc 1 362 0 is_stmt 0 discriminator 1
 1081 0040 FB88     		ldrh	r3, [r7, #6]
 1082 0042 122B     		cmp	r3, #18
 1083 0044 00F0A881 		beq	.L50
 1084 0048 FB88     		ldrh	r3, [r7, #6]
 1085 004a 132B     		cmp	r3, #19
 1086 004c 00F0A481 		beq	.L50
 1087              	.L52:
 363:../src/spark_wiring.c **** 	{
 364:../src/spark_wiring.c **** 		return;
 365:../src/spark_wiring.c **** 	}
 366:../src/spark_wiring.c **** 
 367:../src/spark_wiring.c **** 	if(PIN_MAP[pin].pin_mode != OUTPUT && PIN_MAP[pin].pin_mode != AF_OUTPUT)
 1088              		.loc 1 367 0 is_stmt 1
 1089 0050 FA88     		ldrh	r2, [r7, #6]
 1090 0052 40F20003 		movw	r3, #:lower16:PIN_MAP
 1091 0056 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1092 005a 4FEA0212 		lsl	r2, r2, #4
 1093 005e 9B18     		adds	r3, r3, r2
 1094 0060 03F10803 		add	r3, r3, #8
 1095 0064 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1096 0066 002B     		cmp	r3, #0
 1097 0068 0DD0     		beq	.L53
 1098              		.loc 1 367 0 is_stmt 0 discriminator 1
 1099 006a FA88     		ldrh	r2, [r7, #6]
 1100 006c 40F20003 		movw	r3, #:lower16:PIN_MAP
 1101 0070 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1102 0074 4FEA0212 		lsl	r2, r2, #4
 1103 0078 9B18     		adds	r3, r3, r2
 1104 007a 03F10803 		add	r3, r3, #8
 1105 007e 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 1106 0080 042B     		cmp	r3, #4
 1107 0082 40F08981 		bne	.L50
 1108              	.L53:
 368:../src/spark_wiring.c **** 	{
 369:../src/spark_wiring.c **** 		return;
 370:../src/spark_wiring.c **** 	}
 371:../src/spark_wiring.c **** 
 372:../src/spark_wiring.c **** 	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
 373:../src/spark_wiring.c **** 	TIM_OCInitTypeDef  TIM_OCInitStructure;
 374:../src/spark_wiring.c **** 
 375:../src/spark_wiring.c **** 	//PWM Frequency : 500 Hz
 376:../src/spark_wiring.c **** 	uint16_t TIM_Prescaler = (uint16_t)(SystemCoreClock / 10000) - 1;
 1109              		.loc 1 376 0 is_stmt 1
 1110 0086 40F20003 		movw	r3, #:lower16:SystemCoreClock
 1111 008a C0F20003 		movt	r3, #:upper16:SystemCoreClock
 1112 008e 1A68     		ldr	r2, [r3, #0]
 1113 0090 41F25973 		movw	r3, #5977
 1114 0094 CDF2B713 		movt	r3, 53687
 1115 0098 A3FB0213 		umull	r1, r3, r3, r2
 1116 009c 4FEA5333 		lsr	r3, r3, #13
 1117 00a0 9BB2     		uxth	r3, r3
 1118 00a2 03F1FF33 		add	r3, r3, #-1
 1119 00a6 FB85     		strh	r3, [r7, #46]	@ movhi
 377:../src/spark_wiring.c **** 	uint16_t TIM_ARR = (uint16_t)(10000 / TIM_PWM_FREQ) - 1;
 1120              		.loc 1 377 0
 1121 00a8 4FF01303 		mov	r3, #19
 1122 00ac BB85     		strh	r3, [r7, #44]	@ movhi
 378:../src/spark_wiring.c **** 
 379:../src/spark_wiring.c **** 	uint16_t Duty_Cycle = (uint16_t)((value * 100) / 255);
 1123              		.loc 1 379 0
 1124 00ae 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1125 00b0 4FF06402 		mov	r2, #100
 1126 00b4 02FB03F3 		mul	r3, r2, r3
 1127 00b8 48F28102 		movw	r2, #32897
 1128 00bc C8F28002 		movt	r2, 32896
 1129 00c0 82FB0312 		smull	r1, r2, r2, r3
 1130 00c4 D218     		adds	r2, r2, r3
 1131 00c6 4FEAE212 		asr	r2, r2, #7
 1132 00ca 4FEAE373 		asr	r3, r3, #31
 1133 00ce D31A     		subs	r3, r2, r3
 1134 00d0 7B85     		strh	r3, [r7, #42]	@ movhi
 380:../src/spark_wiring.c **** 	// TIM Channel Duty Cycle(%) = (TIM_CCR / TIM_ARR + 1) * 100
 381:../src/spark_wiring.c **** 	uint16_t TIM_CCR = (uint16_t)((Duty_Cycle * (TIM_ARR + 1)) / 100);
 1135              		.loc 1 381 0
 1136 00d2 7B8D     		ldrh	r3, [r7, #42]
 1137 00d4 BA8D     		ldrh	r2, [r7, #44]
 1138 00d6 02F10102 		add	r2, r2, #1
 1139 00da 02FB03F2 		mul	r2, r2, r3
 1140 00de 48F21F53 		movw	r3, #34079
 1141 00e2 C5F2EB13 		movt	r3, 20971
 1142 00e6 83FB0213 		smull	r1, r3, r3, r2
 1143 00ea 4FEA6311 		asr	r1, r3, #5
 1144 00ee 4FEAE273 		asr	r3, r2, #31
 1145 00f2 CB1A     		subs	r3, r1, r3
 1146 00f4 3B85     		strh	r3, [r7, #40]	@ movhi
 382:../src/spark_wiring.c **** 
 383:../src/spark_wiring.c **** 	// AFIO clock enable
 384:../src/spark_wiring.c **** 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 1147              		.loc 1 384 0
 1148 00f6 4FF00100 		mov	r0, #1
 1149 00fa 4FF00101 		mov	r1, #1
 1150 00fe FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 385:../src/spark_wiring.c **** 
 386:../src/spark_wiring.c **** 	pinMode(pin, AF_OUTPUT);
 1151              		.loc 1 386 0
 1152 0102 FB88     		ldrh	r3, [r7, #6]
 1153 0104 1846     		mov	r0, r3
 1154 0106 4FF00401 		mov	r1, #4
 1155 010a FFF7FEFF 		bl	pinMode
 387:../src/spark_wiring.c **** 
 388:../src/spark_wiring.c **** 	// TIM clock enable
 389:../src/spark_wiring.c **** 	if(PIN_MAP[pin].timer_peripheral == TIM2)
 1156              		.loc 1 389 0
 1157 010e FA88     		ldrh	r2, [r7, #6]
 1158 0110 40F20003 		movw	r3, #:lower16:PIN_MAP
 1159 0114 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1160 0118 4FEA0212 		lsl	r2, r2, #4
 1161 011c 9B18     		adds	r3, r3, r2
 1162 011e 03F10803 		add	r3, r3, #8
 1163 0122 1B68     		ldr	r3, [r3, #0]
 1164 0124 B3F1804F 		cmp	r3, #1073741824
 1165 0128 06D1     		bne	.L54
 390:../src/spark_wiring.c **** 		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
 1166              		.loc 1 390 0
 1167 012a 4FF00100 		mov	r0, #1
 1168 012e 4FF00101 		mov	r1, #1
 1169 0132 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 1170 0136 2EE0     		b	.L55
 1171              	.L54:
 391:../src/spark_wiring.c **** 	else if(PIN_MAP[pin].timer_peripheral == TIM3)
 1172              		.loc 1 391 0
 1173 0138 FA88     		ldrh	r2, [r7, #6]
 1174 013a 40F20003 		movw	r3, #:lower16:PIN_MAP
 1175 013e C0F20003 		movt	r3, #:upper16:PIN_MAP
 1176 0142 4FEA0212 		lsl	r2, r2, #4
 1177 0146 9B18     		adds	r3, r3, r2
 1178 0148 03F10803 		add	r3, r3, #8
 1179 014c 1A68     		ldr	r2, [r3, #0]
 1180 014e 4FF48063 		mov	r3, #1024
 1181 0152 C4F20003 		movt	r3, 16384
 1182 0156 9A42     		cmp	r2, r3
 1183 0158 06D1     		bne	.L56
 392:../src/spark_wiring.c **** 		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
 1184              		.loc 1 392 0
 1185 015a 4FF00200 		mov	r0, #2
 1186 015e 4FF00101 		mov	r1, #1
 1187 0162 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 1188 0166 16E0     		b	.L55
 1189              	.L56:
 393:../src/spark_wiring.c **** 	else if(PIN_MAP[pin].timer_peripheral == TIM4)
 1190              		.loc 1 393 0
 1191 0168 FA88     		ldrh	r2, [r7, #6]
 1192 016a 40F20003 		movw	r3, #:lower16:PIN_MAP
 1193 016e C0F20003 		movt	r3, #:upper16:PIN_MAP
 1194 0172 4FEA0212 		lsl	r2, r2, #4
 1195 0176 9B18     		adds	r3, r3, r2
 1196 0178 03F10803 		add	r3, r3, #8
 1197 017c 1A68     		ldr	r2, [r3, #0]
 1198 017e 4FF40063 		mov	r3, #2048
 1199 0182 C4F20003 		movt	r3, 16384
 1200 0186 9A42     		cmp	r2, r3
 1201 0188 05D1     		bne	.L55
 394:../src/spark_wiring.c **** 		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
 1202              		.loc 1 394 0
 1203 018a 4FF00400 		mov	r0, #4
 1204 018e 4FF00101 		mov	r1, #1
 1205 0192 FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 1206              	.L55:
 395:../src/spark_wiring.c **** 
 396:../src/spark_wiring.c **** 	// Time base configuration
 397:../src/spark_wiring.c **** 	TIM_TimeBaseStructure.TIM_Period = TIM_ARR;
 1207              		.loc 1 397 0
 1208 0196 BB8D     		ldrh	r3, [r7, #44]	@ movhi
 1209 0198 3B84     		strh	r3, [r7, #32]	@ movhi
 398:../src/spark_wiring.c **** 	TIM_TimeBaseStructure.TIM_Prescaler = TIM_Prescaler;
 1210              		.loc 1 398 0
 1211 019a FB8D     		ldrh	r3, [r7, #46]	@ movhi
 1212 019c BB83     		strh	r3, [r7, #28]	@ movhi
 399:../src/spark_wiring.c **** 	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 1213              		.loc 1 399 0
 1214 019e 4FF00003 		mov	r3, #0
 1215 01a2 7B84     		strh	r3, [r7, #34]	@ movhi
 400:../src/spark_wiring.c **** 	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 1216              		.loc 1 400 0
 1217 01a4 4FF00003 		mov	r3, #0
 1218 01a8 FB83     		strh	r3, [r7, #30]	@ movhi
 401:../src/spark_wiring.c **** 
 402:../src/spark_wiring.c **** 	TIM_TimeBaseInit(PIN_MAP[pin].timer_peripheral, &TIM_TimeBaseStructure);
 1219              		.loc 1 402 0
 1220 01aa FA88     		ldrh	r2, [r7, #6]
 1221 01ac 40F20003 		movw	r3, #:lower16:PIN_MAP
 1222 01b0 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1223 01b4 4FEA0212 		lsl	r2, r2, #4
 1224 01b8 9B18     		adds	r3, r3, r2
 1225 01ba 03F10803 		add	r3, r3, #8
 1226 01be 1A68     		ldr	r2, [r3, #0]
 1227 01c0 07F11C03 		add	r3, r7, #28
 1228 01c4 1046     		mov	r0, r2
 1229 01c6 1946     		mov	r1, r3
 1230 01c8 FFF7FEFF 		bl	TIM_TimeBaseInit
 403:../src/spark_wiring.c **** 
 404:../src/spark_wiring.c **** 	// PWM1 Mode configuration
 405:../src/spark_wiring.c **** 	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 1231              		.loc 1 405 0
 1232 01cc 4FF06003 		mov	r3, #96
 1233 01d0 BB81     		strh	r3, [r7, #12]	@ movhi
 406:../src/spark_wiring.c **** 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 1234              		.loc 1 406 0
 1235 01d2 4FF00103 		mov	r3, #1
 1236 01d6 FB81     		strh	r3, [r7, #14]	@ movhi
 407:../src/spark_wiring.c **** 	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 1237              		.loc 1 407 0
 1238 01d8 4FF00003 		mov	r3, #0
 1239 01dc BB82     		strh	r3, [r7, #20]	@ movhi
 408:../src/spark_wiring.c **** 	TIM_OCInitStructure.TIM_Pulse = TIM_CCR;
 1240              		.loc 1 408 0
 1241 01de 3B8D     		ldrh	r3, [r7, #40]	@ movhi
 1242 01e0 7B82     		strh	r3, [r7, #18]	@ movhi
 409:../src/spark_wiring.c **** 
 410:../src/spark_wiring.c **** 	if(PIN_MAP[pin].timer_ch == TIM_Channel_1)
 1243              		.loc 1 410 0
 1244 01e2 FA88     		ldrh	r2, [r7, #6]
 1245 01e4 40F20003 		movw	r3, #:lower16:PIN_MAP
 1246 01e8 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1247 01ec 4FEA0212 		lsl	r2, r2, #4
 1248 01f0 9B18     		adds	r3, r3, r2
 1249 01f2 03F10803 		add	r3, r3, #8
 1250 01f6 9B88     		ldrh	r3, [r3, #4]
 1251 01f8 002B     		cmp	r3, #0
 1252 01fa 21D1     		bne	.L57
 411:../src/spark_wiring.c **** 	{
 412:../src/spark_wiring.c **** 		// PWM1 Mode configuration: Channel1
 413:../src/spark_wiring.c **** 		TIM_OC1Init(PIN_MAP[pin].timer_peripheral, &TIM_OCInitStructure);
 1253              		.loc 1 413 0
 1254 01fc FA88     		ldrh	r2, [r7, #6]
 1255 01fe 40F20003 		movw	r3, #:lower16:PIN_MAP
 1256 0202 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1257 0206 4FEA0212 		lsl	r2, r2, #4
 1258 020a 9B18     		adds	r3, r3, r2
 1259 020c 03F10803 		add	r3, r3, #8
 1260 0210 1A68     		ldr	r2, [r3, #0]
 1261 0212 07F10C03 		add	r3, r7, #12
 1262 0216 1046     		mov	r0, r2
 1263 0218 1946     		mov	r1, r3
 1264 021a FFF7FEFF 		bl	TIM_OC1Init
 414:../src/spark_wiring.c **** 		TIM_OC1PreloadConfig(PIN_MAP[pin].timer_peripheral, TIM_OCPreload_Enable);
 1265              		.loc 1 414 0
 1266 021e FA88     		ldrh	r2, [r7, #6]
 1267 0220 40F20003 		movw	r3, #:lower16:PIN_MAP
 1268 0224 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1269 0228 4FEA0212 		lsl	r2, r2, #4
 1270 022c 9B18     		adds	r3, r3, r2
 1271 022e 03F10803 		add	r3, r3, #8
 1272 0232 1B68     		ldr	r3, [r3, #0]
 1273 0234 1846     		mov	r0, r3
 1274 0236 4FF00801 		mov	r1, #8
 1275 023a FFF7FEFF 		bl	TIM_OC1PreloadConfig
 1276 023e 8BE0     		b	.L58
 1277              	.L57:
 415:../src/spark_wiring.c **** 	}
 416:../src/spark_wiring.c **** 	else if(PIN_MAP[pin].timer_ch == TIM_Channel_2)
 1278              		.loc 1 416 0
 1279 0240 FA88     		ldrh	r2, [r7, #6]
 1280 0242 40F20003 		movw	r3, #:lower16:PIN_MAP
 1281 0246 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1282 024a 4FEA0212 		lsl	r2, r2, #4
 1283 024e 9B18     		adds	r3, r3, r2
 1284 0250 03F10803 		add	r3, r3, #8
 1285 0254 9B88     		ldrh	r3, [r3, #4]
 1286 0256 042B     		cmp	r3, #4
 1287 0258 21D1     		bne	.L59
 417:../src/spark_wiring.c **** 	{
 418:../src/spark_wiring.c **** 		// PWM1 Mode configuration: Channel2
 419:../src/spark_wiring.c **** 		TIM_OC2Init(PIN_MAP[pin].timer_peripheral, &TIM_OCInitStructure);
 1288              		.loc 1 419 0
 1289 025a FA88     		ldrh	r2, [r7, #6]
 1290 025c 40F20003 		movw	r3, #:lower16:PIN_MAP
 1291 0260 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1292 0264 4FEA0212 		lsl	r2, r2, #4
 1293 0268 9B18     		adds	r3, r3, r2
 1294 026a 03F10803 		add	r3, r3, #8
 1295 026e 1A68     		ldr	r2, [r3, #0]
 1296 0270 07F10C03 		add	r3, r7, #12
 1297 0274 1046     		mov	r0, r2
 1298 0276 1946     		mov	r1, r3
 1299 0278 FFF7FEFF 		bl	TIM_OC2Init
 420:../src/spark_wiring.c **** 		TIM_OC2PreloadConfig(PIN_MAP[pin].timer_peripheral, TIM_OCPreload_Enable);
 1300              		.loc 1 420 0
 1301 027c FA88     		ldrh	r2, [r7, #6]
 1302 027e 40F20003 		movw	r3, #:lower16:PIN_MAP
 1303 0282 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1304 0286 4FEA0212 		lsl	r2, r2, #4
 1305 028a 9B18     		adds	r3, r3, r2
 1306 028c 03F10803 		add	r3, r3, #8
 1307 0290 1B68     		ldr	r3, [r3, #0]
 1308 0292 1846     		mov	r0, r3
 1309 0294 4FF00801 		mov	r1, #8
 1310 0298 FFF7FEFF 		bl	TIM_OC2PreloadConfig
 1311 029c 5CE0     		b	.L58
 1312              	.L59:
 421:../src/spark_wiring.c **** 	}
 422:../src/spark_wiring.c **** 	else if(PIN_MAP[pin].timer_ch == TIM_Channel_3)
 1313              		.loc 1 422 0
 1314 029e FA88     		ldrh	r2, [r7, #6]
 1315 02a0 40F20003 		movw	r3, #:lower16:PIN_MAP
 1316 02a4 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1317 02a8 4FEA0212 		lsl	r2, r2, #4
 1318 02ac 9B18     		adds	r3, r3, r2
 1319 02ae 03F10803 		add	r3, r3, #8
 1320 02b2 9B88     		ldrh	r3, [r3, #4]
 1321 02b4 082B     		cmp	r3, #8
 1322 02b6 21D1     		bne	.L60
 423:../src/spark_wiring.c **** 	{
 424:../src/spark_wiring.c **** 		// PWM1 Mode configuration: Channel3
 425:../src/spark_wiring.c **** 		TIM_OC3Init(PIN_MAP[pin].timer_peripheral, &TIM_OCInitStructure);
 1323              		.loc 1 425 0
 1324 02b8 FA88     		ldrh	r2, [r7, #6]
 1325 02ba 40F20003 		movw	r3, #:lower16:PIN_MAP
 1326 02be C0F20003 		movt	r3, #:upper16:PIN_MAP
 1327 02c2 4FEA0212 		lsl	r2, r2, #4
 1328 02c6 9B18     		adds	r3, r3, r2
 1329 02c8 03F10803 		add	r3, r3, #8
 1330 02cc 1A68     		ldr	r2, [r3, #0]
 1331 02ce 07F10C03 		add	r3, r7, #12
 1332 02d2 1046     		mov	r0, r2
 1333 02d4 1946     		mov	r1, r3
 1334 02d6 FFF7FEFF 		bl	TIM_OC3Init
 426:../src/spark_wiring.c **** 		TIM_OC3PreloadConfig(PIN_MAP[pin].timer_peripheral, TIM_OCPreload_Enable);
 1335              		.loc 1 426 0
 1336 02da FA88     		ldrh	r2, [r7, #6]
 1337 02dc 40F20003 		movw	r3, #:lower16:PIN_MAP
 1338 02e0 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1339 02e4 4FEA0212 		lsl	r2, r2, #4
 1340 02e8 9B18     		adds	r3, r3, r2
 1341 02ea 03F10803 		add	r3, r3, #8
 1342 02ee 1B68     		ldr	r3, [r3, #0]
 1343 02f0 1846     		mov	r0, r3
 1344 02f2 4FF00801 		mov	r1, #8
 1345 02f6 FFF7FEFF 		bl	TIM_OC3PreloadConfig
 1346 02fa 2DE0     		b	.L58
 1347              	.L60:
 427:../src/spark_wiring.c **** 	}
 428:../src/spark_wiring.c **** 	else if(PIN_MAP[pin].timer_ch == TIM_Channel_4)
 1348              		.loc 1 428 0
 1349 02fc FA88     		ldrh	r2, [r7, #6]
 1350 02fe 40F20003 		movw	r3, #:lower16:PIN_MAP
 1351 0302 C0F20003 		movt	r3, #:upper16:PIN_MAP
 1352 0306 4FEA0212 		lsl	r2, r2, #4
 1353 030a 9B18     		adds	r3, r3, r2
 1354 030c 03F10803 		add	r3, r3, #8
 1355 0310 9B88     		ldrh	r3, [r3, #4]
 1356 0312 0C2B     		cmp	r3, #12
 1357 0314 20D1     		bne	.L58
 429:../src/spark_wiring.c **** 	{
 430:../src/spark_wiring.c **** 		// PWM1 Mode configuration: Channel4
 431:../src/spark_wiring.c **** 		TIM_OC4Init(PIN_MAP[pin].timer_peripheral, &TIM_OCInitStructure);
 1358              		.loc 1 431 0
 1359 0316 FA88     		ldrh	r2, [r7, #6]
 1360 0318 40F20003 		movw	r3, #:lower16:PIN_MAP
 1361 031c C0F20003 		movt	r3, #:upper16:PIN_MAP
 1362 0320 4FEA0212 		lsl	r2, r2, #4
 1363 0324 9B18     		adds	r3, r3, r2
 1364 0326 03F10803 		add	r3, r3, #8
 1365 032a 1A68     		ldr	r2, [r3, #0]
 1366 032c 07F10C03 		add	r3, r7, #12
 1367 0330 1046     		mov	r0, r2
 1368 0332 1946     		mov	r1, r3
 1369 0334 FFF7FEFF 		bl	TIM_OC4Init
 432:../src/spark_wiring.c **** 		TIM_OC4PreloadConfig(PIN_MAP[pin].timer_peripheral, TIM_OCPreload_Enable);
 1370              		.loc 1 432 0
 1371 0338 FA88     		ldrh	r2, [r7, #6]
 1372 033a 40F20003 		movw	r3, #:lower16:PIN_MAP
 1373 033e C0F20003 		movt	r3, #:upper16:PIN_MAP
 1374 0342 4FEA0212 		lsl	r2, r2, #4
 1375 0346 9B18     		adds	r3, r3, r2
 1376 0348 03F10803 		add	r3, r3, #8
 1377 034c 1B68     		ldr	r3, [r3, #0]
 1378 034e 1846     		mov	r0, r3
 1379 0350 4FF00801 		mov	r1, #8
 1380 0354 FFF7FEFF 		bl	TIM_OC4PreloadConfig
 1381              	.L58:
 433:../src/spark_wiring.c **** 	}
 434:../src/spark_wiring.c **** 
 435:../src/spark_wiring.c **** 	TIM_ARRPreloadConfig(PIN_MAP[pin].timer_peripheral, ENABLE);
 1382              		.loc 1 435 0
 1383 0358 FA88     		ldrh	r2, [r7, #6]
 1384 035a 40F20003 		movw	r3, #:lower16:PIN_MAP
 1385 035e C0F20003 		movt	r3, #:upper16:PIN_MAP
 1386 0362 4FEA0212 		lsl	r2, r2, #4
 1387 0366 9B18     		adds	r3, r3, r2
 1388 0368 03F10803 		add	r3, r3, #8
 1389 036c 1B68     		ldr	r3, [r3, #0]
 1390 036e 1846     		mov	r0, r3
 1391 0370 4FF00101 		mov	r1, #1
 1392 0374 FFF7FEFF 		bl	TIM_ARRPreloadConfig
 436:../src/spark_wiring.c **** 
 437:../src/spark_wiring.c **** 	// TIM enable counter
 438:../src/spark_wiring.c **** 	TIM_Cmd(PIN_MAP[pin].timer_peripheral, ENABLE);
 1393              		.loc 1 438 0
 1394 0378 FA88     		ldrh	r2, [r7, #6]
 1395 037a 40F20003 		movw	r3, #:lower16:PIN_MAP
 1396 037e C0F20003 		movt	r3, #:upper16:PIN_MAP
 1397 0382 4FEA0212 		lsl	r2, r2, #4
 1398 0386 9B18     		adds	r3, r3, r2
 1399 0388 03F10803 		add	r3, r3, #8
 1400 038c 1B68     		ldr	r3, [r3, #0]
 1401 038e 1846     		mov	r0, r3
 1402 0390 4FF00101 		mov	r1, #1
 1403 0394 FFF7FEFF 		bl	TIM_Cmd
 1404              	.L50:
 439:../src/spark_wiring.c **** }
 1405              		.loc 1 439 0
 1406 0398 07F13007 		add	r7, r7, #48
 1407 039c BD46     		mov	sp, r7
 1408 039e 80BD     		pop	{r7, pc}
 1409              		.cfi_endproc
 1410              	.LFE61:
 1412              		.section	.text.millis,"ax",%progbits
 1413              		.align	2
 1414              		.global	millis
 1415              		.thumb
 1416              		.thumb_func
 1418              	millis:
 1419              	.LFB62:
 440:../src/spark_wiring.c **** 
 441:../src/spark_wiring.c **** /*
 442:../src/spark_wiring.c ****  * TIMING
 443:../src/spark_wiring.c ****  */
 444:../src/spark_wiring.c **** 
 445:../src/spark_wiring.c **** /*
 446:../src/spark_wiring.c ****  * @brief Should return the number of milliseconds since the processor started up.
 447:../src/spark_wiring.c ****  * 		  This is useful for measuring the passage of time.
 448:../src/spark_wiring.c ****  * 		  For now, let's not worry about what happens when this overflows (which should happen after 4
 449:../src/spark_wiring.c ****  * 		  At some point we'll have to figure that out, though.
 450:../src/spark_wiring.c ****  */
 451:../src/spark_wiring.c **** uint32_t millis()
 452:../src/spark_wiring.c **** {
 1420              		.loc 1 452 0
 1421              		.cfi_startproc
 1422              		@ args = 0, pretend = 0, frame = 0
 1423              		@ frame_needed = 1, uses_anonymous_args = 0
 1424              		@ link register save eliminated.
 1425 0000 80B4     		push	{r7}
 1426              	.LCFI18:
 1427              		.cfi_def_cfa_offset 4
 1428              		.cfi_offset 7, -4
 1429 0002 00AF     		add	r7, sp, #0
 1430              	.LCFI19:
 1431              		.cfi_def_cfa_register 7
 453:../src/spark_wiring.c **** 	return TimingMillis;
 1432              		.loc 1 453 0
 1433 0004 40F20003 		movw	r3, #:lower16:TimingMillis
 1434 0008 C0F20003 		movt	r3, #:upper16:TimingMillis
 1435 000c 1B68     		ldr	r3, [r3, #0]
 454:../src/spark_wiring.c **** }
 1436              		.loc 1 454 0
 1437 000e 1846     		mov	r0, r3
 1438 0010 BD46     		mov	sp, r7
 1439 0012 80BC     		pop	{r7}
 1440 0014 7047     		bx	lr
 1441              		.cfi_endproc
 1442              	.LFE62:
 1444 0016 00BF     		.section	.text.delay,"ax",%progbits
 1445              		.align	2
 1446              		.global	delay
 1447              		.thumb
 1448              		.thumb_func
 1450              	delay:
 1451              	.LFB63:
 455:../src/spark_wiring.c **** 
 456:../src/spark_wiring.c **** /*
 457:../src/spark_wiring.c ****  * @brief This should block for a certain number of milliseconds.
 458:../src/spark_wiring.c ****  *        There are a number of ways to implement this, but I borrowed the one that Wiring/Arduino 
 459:../src/spark_wiring.c ****  *        Using the millis() function to check if a certain amount of time has passed.
 460:../src/spark_wiring.c ****  */
 461:../src/spark_wiring.c **** void delay(uint32_t ms)
 462:../src/spark_wiring.c **** {
 1452              		.loc 1 462 0
 1453              		.cfi_startproc
 1454              		@ args = 0, pretend = 0, frame = 8
 1455              		@ frame_needed = 1, uses_anonymous_args = 0
 1456 0000 80B5     		push	{r7, lr}
 1457              	.LCFI20:
 1458              		.cfi_def_cfa_offset 8
 1459              		.cfi_offset 7, -8
 1460              		.cfi_offset 14, -4
 1461 0002 82B0     		sub	sp, sp, #8
 1462              	.LCFI21:
 1463              		.cfi_def_cfa_offset 16
 1464 0004 00AF     		add	r7, sp, #0
 1465              	.LCFI22:
 1466              		.cfi_def_cfa_register 7
 1467 0006 7860     		str	r0, [r7, #4]
 463:../src/spark_wiring.c **** 	//uint32_t start = millis();
 464:../src/spark_wiring.c **** 	//while(millis() - start < ms);
 465:../src/spark_wiring.c **** 	//OR
 466:../src/spark_wiring.c **** 	//Use the Delay() from main.c
 467:../src/spark_wiring.c **** 	Delay(ms);
 1468              		.loc 1 467 0
 1469 0008 7868     		ldr	r0, [r7, #4]
 1470 000a FFF7FEFF 		bl	Delay
 468:../src/spark_wiring.c **** }
 1471              		.loc 1 468 0
 1472 000e 07F10807 		add	r7, r7, #8
 1473 0012 BD46     		mov	sp, r7
 1474 0014 80BD     		pop	{r7, pc}
 1475              		.cfi_endproc
 1476              	.LFE63:
 1478 0016 00BF     		.section	.text.delayMicroseconds,"ax",%progbits
 1479              		.align	2
 1480              		.global	delayMicroseconds
 1481              		.thumb
 1482              		.thumb_func
 1484              	delayMicroseconds:
 1485              	.LFB64:
 469:../src/spark_wiring.c **** 
 470:../src/spark_wiring.c **** /*
 471:../src/spark_wiring.c ****  * @brief This should block for a certain number of microseconds.
 472:../src/spark_wiring.c ****  *        This will only be used for small intervals of time, so it has different requirements than
 473:../src/spark_wiring.c ****  *        It must be accurate at small intervals, but does not have to function properly
 474:../src/spark_wiring.c ****  *        with intervals more than a couple of seconds.
 475:../src/spark_wiring.c ****  *
 476:../src/spark_wiring.c ****  *        The below implementation is borrowed straight from Maple. I do not understand the code, n
 477:../src/spark_wiring.c ****  *        understand the derivation of the multiplier.
 478:../src/spark_wiring.c ****  *
 479:../src/spark_wiring.c ****  *        This function is lower priority than the others.
 480:../src/spark_wiring.c ****  */
 481:../src/spark_wiring.c **** void delayMicroseconds(uint32_t us)
 482:../src/spark_wiring.c **** {
 1486              		.loc 1 482 0
 1487              		.cfi_startproc
 1488              		@ args = 0, pretend = 0, frame = 8
 1489              		@ frame_needed = 1, uses_anonymous_args = 0
 1490              		@ link register save eliminated.
 1491 0000 80B4     		push	{r7}
 1492              	.LCFI23:
 1493              		.cfi_def_cfa_offset 4
 1494              		.cfi_offset 7, -4
 1495 0002 83B0     		sub	sp, sp, #12
 1496              	.LCFI24:
 1497              		.cfi_def_cfa_offset 16
 1498 0004 00AF     		add	r7, sp, #0
 1499              	.LCFI25:
 1500              		.cfi_def_cfa_register 7
 1501 0006 7860     		str	r0, [r7, #4]
 483:../src/spark_wiring.c **** 	// We have to multiply this by something, but I'm not sure what.
 484:../src/spark_wiring.c **** 	// Depends on how many clock cycles the below assembly code takes, I suppose.
 485:../src/spark_wiring.c **** 	//
 486:../src/spark_wiring.c **** 	/*
 487:../src/spark_wiring.c **** 	 us *= STM32_DELAY_US_MULT;
 488:../src/spark_wiring.c **** 
 489:../src/spark_wiring.c **** 	 // fudge for function call overhead
 490:../src/spark_wiring.c **** 	 us--;
 491:../src/spark_wiring.c **** 	 asm volatile("   mov r0, %[us]          \n\t"
 492:../src/spark_wiring.c **** 	 "1: subs r0, #1            \n\t"
 493:../src/spark_wiring.c **** 	 "   bhi 1b                 \n\t"
 494:../src/spark_wiring.c **** 	 :
 495:../src/spark_wiring.c **** 	 : [us] "r" (us)
 496:../src/spark_wiring.c **** 	 : "r0");
 497:../src/spark_wiring.c **** 	 */
 498:../src/spark_wiring.c **** }
 1502              		.loc 1 498 0
 1503 0008 07F10C07 		add	r7, r7, #12
 1504 000c BD46     		mov	sp, r7
 1505 000e 80BC     		pop	{r7}
 1506 0010 7047     		bx	lr
 1507              		.cfi_endproc
 1508              	.LFE64:
 1510 0012 00BF     		.section	.text.serial_begin,"ax",%progbits
 1511              		.align	2
 1512              		.global	serial_begin
 1513              		.thumb
 1514              		.thumb_func
 1516              	serial_begin:
 1517              	.LFB65:
 499:../src/spark_wiring.c **** 
 500:../src/spark_wiring.c **** void serial_begin(uint32_t baudRate)
 501:../src/spark_wiring.c **** {
 1518              		.loc 1 501 0
 1519              		.cfi_startproc
 1520              		@ args = 0, pretend = 0, frame = 8
 1521              		@ frame_needed = 1, uses_anonymous_args = 0
 1522 0000 80B5     		push	{r7, lr}
 1523              	.LCFI26:
 1524              		.cfi_def_cfa_offset 8
 1525              		.cfi_offset 7, -8
 1526              		.cfi_offset 14, -4
 1527 0002 82B0     		sub	sp, sp, #8
 1528              	.LCFI27:
 1529              		.cfi_def_cfa_offset 16
 1530 0004 00AF     		add	r7, sp, #0
 1531              	.LCFI28:
 1532              		.cfi_def_cfa_register 7
 1533 0006 7860     		str	r0, [r7, #4]
 502:../src/spark_wiring.c **** 	USB_USART_Init(baudRate);
 1534              		.loc 1 502 0
 1535 0008 7868     		ldr	r0, [r7, #4]
 1536 000a FFF7FEFF 		bl	USB_USART_Init
 503:../src/spark_wiring.c **** }
 1537              		.loc 1 503 0
 1538 000e 07F10807 		add	r7, r7, #8
 1539 0012 BD46     		mov	sp, r7
 1540 0014 80BD     		pop	{r7, pc}
 1541              		.cfi_endproc
 1542              	.LFE65:
 1544 0016 00BF     		.section	.text.serial_end,"ax",%progbits
 1545              		.align	2
 1546              		.global	serial_end
 1547              		.thumb
 1548              		.thumb_func
 1550              	serial_end:
 1551              	.LFB66:
 504:../src/spark_wiring.c **** 
 505:../src/spark_wiring.c **** void serial_end(void)
 506:../src/spark_wiring.c **** {
 1552              		.loc 1 506 0
 1553              		.cfi_startproc
 1554              		@ args = 0, pretend = 0, frame = 0
 1555              		@ frame_needed = 1, uses_anonymous_args = 0
 1556              		@ link register save eliminated.
 1557 0000 80B4     		push	{r7}
 1558              	.LCFI29:
 1559              		.cfi_def_cfa_offset 4
 1560              		.cfi_offset 7, -4
 1561 0002 00AF     		add	r7, sp, #0
 1562              	.LCFI30:
 1563              		.cfi_def_cfa_register 7
 507:../src/spark_wiring.c **** 	//To Do
 508:../src/spark_wiring.c **** }
 1564              		.loc 1 508 0
 1565 0004 BD46     		mov	sp, r7
 1566 0006 80BC     		pop	{r7}
 1567 0008 7047     		bx	lr
 1568              		.cfi_endproc
 1569              	.LFE66:
 1571 000a 00BF     		.section	.text.serial_available,"ax",%progbits
 1572              		.align	2
 1573              		.global	serial_available
 1574              		.thumb
 1575              		.thumb_func
 1577              	serial_available:
 1578              	.LFB67:
 509:../src/spark_wiring.c **** 
 510:../src/spark_wiring.c **** uint8_t serial_available(void)
 511:../src/spark_wiring.c **** {
 1579              		.loc 1 511 0
 1580              		.cfi_startproc
 1581              		@ args = 0, pretend = 0, frame = 0
 1582              		@ frame_needed = 1, uses_anonymous_args = 0
 1583 0000 80B5     		push	{r7, lr}
 1584              	.LCFI31:
 1585              		.cfi_def_cfa_offset 8
 1586              		.cfi_offset 7, -8
 1587              		.cfi_offset 14, -4
 1588 0002 00AF     		add	r7, sp, #0
 1589              	.LCFI32:
 1590              		.cfi_def_cfa_register 7
 512:../src/spark_wiring.c **** 	return USB_USART_Available_Data();
 1591              		.loc 1 512 0
 1592 0004 FFF7FEFF 		bl	USB_USART_Available_Data
 1593 0008 0346     		mov	r3, r0
 513:../src/spark_wiring.c **** }
 1594              		.loc 1 513 0
 1595 000a 1846     		mov	r0, r3
 1596 000c 80BD     		pop	{r7, pc}
 1597              		.cfi_endproc
 1598              	.LFE67:
 1600 000e 00BF     		.section	.text.serial_read,"ax",%progbits
 1601              		.align	2
 1602              		.global	serial_read
 1603              		.thumb
 1604              		.thumb_func
 1606              	serial_read:
 1607              	.LFB68:
 514:../src/spark_wiring.c **** 
 515:../src/spark_wiring.c **** int32_t serial_read(void)
 516:../src/spark_wiring.c **** {
 1608              		.loc 1 516 0
 1609              		.cfi_startproc
 1610              		@ args = 0, pretend = 0, frame = 0
 1611              		@ frame_needed = 1, uses_anonymous_args = 0
 1612 0000 80B5     		push	{r7, lr}
 1613              	.LCFI33:
 1614              		.cfi_def_cfa_offset 8
 1615              		.cfi_offset 7, -8
 1616              		.cfi_offset 14, -4
 1617 0002 00AF     		add	r7, sp, #0
 1618              	.LCFI34:
 1619              		.cfi_def_cfa_register 7
 517:../src/spark_wiring.c **** 	return USB_USART_Receive_Data();
 1620              		.loc 1 517 0
 1621 0004 FFF7FEFF 		bl	USB_USART_Receive_Data
 1622 0008 0346     		mov	r3, r0
 518:../src/spark_wiring.c **** }
 1623              		.loc 1 518 0
 1624 000a 1846     		mov	r0, r3
 1625 000c 80BD     		pop	{r7, pc}
 1626              		.cfi_endproc
 1627              	.LFE68:
 1629 000e 00BF     		.section	.text.serial_write,"ax",%progbits
 1630              		.align	2
 1631              		.global	serial_write
 1632              		.thumb
 1633              		.thumb_func
 1635              	serial_write:
 1636              	.LFB69:
 519:../src/spark_wiring.c **** 
 520:../src/spark_wiring.c **** void serial_write(uint8_t Data)
 521:../src/spark_wiring.c **** {
 1637              		.loc 1 521 0
 1638              		.cfi_startproc
 1639              		@ args = 0, pretend = 0, frame = 8
 1640              		@ frame_needed = 1, uses_anonymous_args = 0
 1641 0000 80B5     		push	{r7, lr}
 1642              	.LCFI35:
 1643              		.cfi_def_cfa_offset 8
 1644              		.cfi_offset 7, -8
 1645              		.cfi_offset 14, -4
 1646 0002 82B0     		sub	sp, sp, #8
 1647              	.LCFI36:
 1648              		.cfi_def_cfa_offset 16
 1649 0004 00AF     		add	r7, sp, #0
 1650              	.LCFI37:
 1651              		.cfi_def_cfa_register 7
 1652 0006 0346     		mov	r3, r0
 1653 0008 FB71     		strb	r3, [r7, #7]
 522:../src/spark_wiring.c **** 	USB_USART_Send_Data(Data);
 1654              		.loc 1 522 0
 1655 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1656 000c 1846     		mov	r0, r3
 1657 000e FFF7FEFF 		bl	USB_USART_Send_Data
 523:../src/spark_wiring.c **** }
 1658              		.loc 1 523 0
 1659 0012 07F10807 		add	r7, r7, #8
 1660 0016 BD46     		mov	sp, r7
 1661 0018 80BD     		pop	{r7, pc}
 1662              		.cfi_endproc
 1663              	.LFE69:
 1665 001a 00BF     		.section	.text.serial_print,"ax",%progbits
 1666              		.align	2
 1667              		.global	serial_print
 1668              		.thumb
 1669              		.thumb_func
 1671              	serial_print:
 1672              	.LFB70:
 524:../src/spark_wiring.c **** 
 525:../src/spark_wiring.c **** void serial_print(const char * str)
 526:../src/spark_wiring.c **** {
 1673              		.loc 1 526 0
 1674              		.cfi_startproc
 1675              		@ args = 0, pretend = 0, frame = 8
 1676              		@ frame_needed = 1, uses_anonymous_args = 0
 1677 0000 80B5     		push	{r7, lr}
 1678              	.LCFI38:
 1679              		.cfi_def_cfa_offset 8
 1680              		.cfi_offset 7, -8
 1681              		.cfi_offset 14, -4
 1682 0002 82B0     		sub	sp, sp, #8
 1683              	.LCFI39:
 1684              		.cfi_def_cfa_offset 16
 1685 0004 00AF     		add	r7, sp, #0
 1686              	.LCFI40:
 1687              		.cfi_def_cfa_register 7
 1688 0006 7860     		str	r0, [r7, #4]
 527:../src/spark_wiring.c **** 	while (*str)
 1689              		.loc 1 527 0
 1690 0008 08E0     		b	.L74
 1691              	.L75:
 528:../src/spark_wiring.c **** 	{
 529:../src/spark_wiring.c **** 		serial_write(*str++);
 1692              		.loc 1 529 0
 1693 000a 7B68     		ldr	r3, [r7, #4]
 1694 000c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1695 000e 7A68     		ldr	r2, [r7, #4]
 1696 0010 02F10102 		add	r2, r2, #1
 1697 0014 7A60     		str	r2, [r7, #4]
 1698 0016 1846     		mov	r0, r3
 1699 0018 FFF7FEFF 		bl	serial_write
 1700              	.L74:
 527:../src/spark_wiring.c **** 	while (*str)
 1701              		.loc 1 527 0 discriminator 1
 1702 001c 7B68     		ldr	r3, [r7, #4]
 1703 001e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 1704 0020 002B     		cmp	r3, #0
 1705 0022 F2D1     		bne	.L75
 530:../src/spark_wiring.c **** 	}
 531:../src/spark_wiring.c **** }
 1706              		.loc 1 531 0
 1707 0024 07F10807 		add	r7, r7, #8
 1708 0028 BD46     		mov	sp, r7
 1709 002a 80BD     		pop	{r7, pc}
 1710              		.cfi_endproc
 1711              	.LFE70:
 1713              		.section	.rodata
 1714              		.align	2
 1715              	.LC0:
 1716 0000 0D0A00   		.ascii	"\015\012\000"
 1717 0003 00       		.section	.text.serial_println,"ax",%progbits
 1718              		.align	2
 1719              		.global	serial_println
 1720              		.thumb
 1721              		.thumb_func
 1723              	serial_println:
 1724              	.LFB71:
 532:../src/spark_wiring.c **** 
 533:../src/spark_wiring.c **** void serial_println(const char * str)
 534:../src/spark_wiring.c **** {
 1725              		.loc 1 534 0
 1726              		.cfi_startproc
 1727              		@ args = 0, pretend = 0, frame = 8
 1728              		@ frame_needed = 1, uses_anonymous_args = 0
 1729 0000 80B5     		push	{r7, lr}
 1730              	.LCFI41:
 1731              		.cfi_def_cfa_offset 8
 1732              		.cfi_offset 7, -8
 1733              		.cfi_offset 14, -4
 1734 0002 82B0     		sub	sp, sp, #8
 1735              	.LCFI42:
 1736              		.cfi_def_cfa_offset 16
 1737 0004 00AF     		add	r7, sp, #0
 1738              	.LCFI43:
 1739              		.cfi_def_cfa_register 7
 1740 0006 7860     		str	r0, [r7, #4]
 535:../src/spark_wiring.c **** 	serial_print(str);
 1741              		.loc 1 535 0
 1742 0008 7868     		ldr	r0, [r7, #4]
 1743 000a FFF7FEFF 		bl	serial_print
 536:../src/spark_wiring.c **** 	serial_print("\r\n");
 1744              		.loc 1 536 0
 1745 000e 40F20000 		movw	r0, #:lower16:.LC0
 1746 0012 C0F20000 		movt	r0, #:upper16:.LC0
 1747 0016 FFF7FEFF 		bl	serial_print
 537:../src/spark_wiring.c **** }
 1748              		.loc 1 537 0
 1749 001a 07F10807 		add	r7, r7, #8
 1750 001e BD46     		mov	sp, r7
 1751 0020 80BD     		pop	{r7, pc}
 1752              		.cfi_endproc
 1753              	.LFE71:
 1755 0022 00BF     		.section	.text.serial1_begin,"ax",%progbits
 1756              		.align	2
 1757              		.global	serial1_begin
 1758              		.thumb
 1759              		.thumb_func
 1761              	serial1_begin:
 1762              	.LFB72:
 538:../src/spark_wiring.c **** 
 539:../src/spark_wiring.c **** void serial1_begin(uint32_t baudRate)
 540:../src/spark_wiring.c **** {
 1763              		.loc 1 540 0
 1764              		.cfi_startproc
 1765              		@ args = 0, pretend = 0, frame = 24
 1766              		@ frame_needed = 1, uses_anonymous_args = 0
 1767 0000 80B5     		push	{r7, lr}
 1768              	.LCFI44:
 1769              		.cfi_def_cfa_offset 8
 1770              		.cfi_offset 7, -8
 1771              		.cfi_offset 14, -4
 1772 0002 86B0     		sub	sp, sp, #24
 1773              	.LCFI45:
 1774              		.cfi_def_cfa_offset 32
 1775 0004 00AF     		add	r7, sp, #0
 1776              	.LCFI46:
 1777              		.cfi_def_cfa_register 7
 1778 0006 7860     		str	r0, [r7, #4]
 541:../src/spark_wiring.c **** 	USART_InitTypeDef USART_InitStructure;
 542:../src/spark_wiring.c **** 
 543:../src/spark_wiring.c **** 	// AFIO clock enable
 544:../src/spark_wiring.c **** 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 1779              		.loc 1 544 0
 1780 0008 4FF00100 		mov	r0, #1
 1781 000c 4FF00101 		mov	r1, #1
 1782 0010 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 545:../src/spark_wiring.c **** 
 546:../src/spark_wiring.c **** 	// Enable USART Clock
 547:../src/spark_wiring.c **** 	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 1783              		.loc 1 547 0
 1784 0014 4FF40030 		mov	r0, #131072
 1785 0018 4FF00101 		mov	r1, #1
 1786 001c FFF7FEFF 		bl	RCC_APB1PeriphClockCmd
 548:../src/spark_wiring.c **** 
 549:../src/spark_wiring.c **** 	// Configure USART Rx as input floating
 550:../src/spark_wiring.c **** 	pinMode(RX, INPUT);
 1787              		.loc 1 550 0
 1788 0020 4FF01200 		mov	r0, #18
 1789 0024 4FF00101 		mov	r1, #1
 1790 0028 FFF7FEFF 		bl	pinMode
 551:../src/spark_wiring.c **** 
 552:../src/spark_wiring.c **** 	// Configure USART Tx as alternate function push-pull
 553:../src/spark_wiring.c **** 	pinMode(TX, AF_OUTPUT);
 1791              		.loc 1 553 0
 1792 002c 4FF01300 		mov	r0, #19
 1793 0030 4FF00401 		mov	r1, #4
 1794 0034 FFF7FEFF 		bl	pinMode
 554:../src/spark_wiring.c **** 
 555:../src/spark_wiring.c **** 	// USART default configuration
 556:../src/spark_wiring.c **** 	// USART configured as follow:
 557:../src/spark_wiring.c **** 	// - BaudRate = (set baudRate as 9600 baud)
 558:../src/spark_wiring.c **** 	// - Word Length = 8 Bits
 559:../src/spark_wiring.c **** 	// - One Stop Bit
 560:../src/spark_wiring.c **** 	// - No parity
 561:../src/spark_wiring.c **** 	// - Hardware flow control disabled (RTS and CTS signals)
 562:../src/spark_wiring.c **** 	// - Receive and transmit enabled
 563:../src/spark_wiring.c **** 	USART_InitStructure.USART_BaudRate = baudRate;
 1795              		.loc 1 563 0
 1796 0038 7B68     		ldr	r3, [r7, #4]
 1797 003a BB60     		str	r3, [r7, #8]
 564:../src/spark_wiring.c **** 	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 1798              		.loc 1 564 0
 1799 003c 4FF00003 		mov	r3, #0
 1800 0040 BB81     		strh	r3, [r7, #12]	@ movhi
 565:../src/spark_wiring.c **** 	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 1801              		.loc 1 565 0
 1802 0042 4FF00003 		mov	r3, #0
 1803 0046 FB81     		strh	r3, [r7, #14]	@ movhi
 566:../src/spark_wiring.c **** 	USART_InitStructure.USART_Parity = USART_Parity_No;
 1804              		.loc 1 566 0
 1805 0048 4FF00003 		mov	r3, #0
 1806 004c 3B82     		strh	r3, [r7, #16]	@ movhi
 567:../src/spark_wiring.c **** 	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 1807              		.loc 1 567 0
 1808 004e 4FF00003 		mov	r3, #0
 1809 0052 BB82     		strh	r3, [r7, #20]	@ movhi
 568:../src/spark_wiring.c **** 	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 1810              		.loc 1 568 0
 1811 0054 4FF00C03 		mov	r3, #12
 1812 0058 7B82     		strh	r3, [r7, #18]	@ movhi
 569:../src/spark_wiring.c **** 
 570:../src/spark_wiring.c **** 	// Configure USART
 571:../src/spark_wiring.c **** 	USART_Init(USART2, &USART_InitStructure);
 1813              		.loc 1 571 0
 1814 005a 07F10803 		add	r3, r7, #8
 1815 005e 4FF48840 		mov	r0, #17408
 1816 0062 C4F20000 		movt	r0, 16384
 1817 0066 1946     		mov	r1, r3
 1818 0068 FFF7FEFF 		bl	USART_Init
 572:../src/spark_wiring.c **** 
 573:../src/spark_wiring.c **** 	// Enable the USART
 574:../src/spark_wiring.c **** 	USART_Cmd(USART2, ENABLE);
 1819              		.loc 1 574 0
 1820 006c 4FF48840 		mov	r0, #17408
 1821 0070 C4F20000 		movt	r0, 16384
 1822 0074 4FF00101 		mov	r1, #1
 1823 0078 FFF7FEFF 		bl	USART_Cmd
 575:../src/spark_wiring.c **** 
 576:../src/spark_wiring.c **** 	serial1_enabled = true;
 1824              		.loc 1 576 0
 1825 007c 40F20003 		movw	r3, #:lower16:serial1_enabled
 1826 0080 C0F20003 		movt	r3, #:upper16:serial1_enabled
 1827 0084 4FF00102 		mov	r2, #1
 1828 0088 1A70     		strb	r2, [r3, #0]
 577:../src/spark_wiring.c **** }
 1829              		.loc 1 577 0
 1830 008a 07F11807 		add	r7, r7, #24
 1831 008e BD46     		mov	sp, r7
 1832 0090 80BD     		pop	{r7, pc}
 1833              		.cfi_endproc
 1834              	.LFE72:
 1836 0092 00BF     		.section	.text.serial1_end,"ax",%progbits
 1837              		.align	2
 1838              		.global	serial1_end
 1839              		.thumb
 1840              		.thumb_func
 1842              	serial1_end:
 1843              	.LFB73:
 578:../src/spark_wiring.c **** 
 579:../src/spark_wiring.c **** void serial1_end(void)
 580:../src/spark_wiring.c **** {
 1844              		.loc 1 580 0
 1845              		.cfi_startproc
 1846              		@ args = 0, pretend = 0, frame = 0
 1847              		@ frame_needed = 1, uses_anonymous_args = 0
 1848 0000 80B5     		push	{r7, lr}
 1849              	.LCFI47:
 1850              		.cfi_def_cfa_offset 8
 1851              		.cfi_offset 7, -8
 1852              		.cfi_offset 14, -4
 1853 0002 00AF     		add	r7, sp, #0
 1854              	.LCFI48:
 1855              		.cfi_def_cfa_register 7
 581:../src/spark_wiring.c **** 	// Disable the USART
 582:../src/spark_wiring.c **** 	USART_Cmd(USART2, DISABLE);
 1856              		.loc 1 582 0
 1857 0004 4FF48840 		mov	r0, #17408
 1858 0008 C4F20000 		movt	r0, 16384
 1859 000c 4FF00001 		mov	r1, #0
 1860 0010 FFF7FEFF 		bl	USART_Cmd
 583:../src/spark_wiring.c **** 
 584:../src/spark_wiring.c **** 	serial1_enabled = false;
 1861              		.loc 1 584 0
 1862 0014 40F20003 		movw	r3, #:lower16:serial1_enabled
 1863 0018 C0F20003 		movt	r3, #:upper16:serial1_enabled
 1864 001c 4FF00002 		mov	r2, #0
 1865 0020 1A70     		strb	r2, [r3, #0]
 585:../src/spark_wiring.c **** }
 1866              		.loc 1 585 0
 1867 0022 80BD     		pop	{r7, pc}
 1868              		.cfi_endproc
 1869              	.LFE73:
 1871              		.section	.text.serial1_available,"ax",%progbits
 1872              		.align	2
 1873              		.global	serial1_available
 1874              		.thumb
 1875              		.thumb_func
 1877              	serial1_available:
 1878              	.LFB74:
 586:../src/spark_wiring.c **** 
 587:../src/spark_wiring.c **** uint8_t serial1_available(void)
 588:../src/spark_wiring.c **** {
 1879              		.loc 1 588 0
 1880              		.cfi_startproc
 1881              		@ args = 0, pretend = 0, frame = 0
 1882              		@ frame_needed = 1, uses_anonymous_args = 0
 1883 0000 80B5     		push	{r7, lr}
 1884              	.LCFI49:
 1885              		.cfi_def_cfa_offset 8
 1886              		.cfi_offset 7, -8
 1887              		.cfi_offset 14, -4
 1888 0002 00AF     		add	r7, sp, #0
 1889              	.LCFI50:
 1890              		.cfi_def_cfa_register 7
 589:../src/spark_wiring.c **** 	// Check if the USART Receive Data Register is not empty
 590:../src/spark_wiring.c **** 	if(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) != RESET)
 1891              		.loc 1 590 0
 1892 0004 4FF48840 		mov	r0, #17408
 1893 0008 C4F20000 		movt	r0, 16384
 1894 000c 4FF02001 		mov	r1, #32
 1895 0010 FFF7FEFF 		bl	USART_GetFlagStatus
 1896 0014 0346     		mov	r3, r0
 1897 0016 002B     		cmp	r3, #0
 1898 0018 02D0     		beq	.L80
 591:../src/spark_wiring.c **** 		return 1;
 1899              		.loc 1 591 0
 1900 001a 4FF00103 		mov	r3, #1
 1901 001e 01E0     		b	.L81
 1902              	.L80:
 592:../src/spark_wiring.c **** 	else
 593:../src/spark_wiring.c **** 		return 0;
 1903              		.loc 1 593 0
 1904 0020 4FF00003 		mov	r3, #0
 1905              	.L81:
 594:../src/spark_wiring.c **** }
 1906              		.loc 1 594 0
 1907 0024 1846     		mov	r0, r3
 1908 0026 80BD     		pop	{r7, pc}
 1909              		.cfi_endproc
 1910              	.LFE74:
 1912              		.section	.text.serial1_read,"ax",%progbits
 1913              		.align	2
 1914              		.global	serial1_read
 1915              		.thumb
 1916              		.thumb_func
 1918              	serial1_read:
 1919              	.LFB75:
 595:../src/spark_wiring.c **** 
 596:../src/spark_wiring.c **** int32_t serial1_read(void)
 597:../src/spark_wiring.c **** {
 1920              		.loc 1 597 0
 1921              		.cfi_startproc
 1922              		@ args = 0, pretend = 0, frame = 0
 1923              		@ frame_needed = 1, uses_anonymous_args = 0
 1924 0000 80B5     		push	{r7, lr}
 1925              	.LCFI51:
 1926              		.cfi_def_cfa_offset 8
 1927              		.cfi_offset 7, -8
 1928              		.cfi_offset 14, -4
 1929 0002 00AF     		add	r7, sp, #0
 1930              	.LCFI52:
 1931              		.cfi_def_cfa_register 7
 598:../src/spark_wiring.c **** 	// Return the received byte
 599:../src/spark_wiring.c **** 	return USART_ReceiveData(USART2);
 1932              		.loc 1 599 0
 1933 0004 4FF48840 		mov	r0, #17408
 1934 0008 C4F20000 		movt	r0, 16384
 1935 000c FFF7FEFF 		bl	USART_ReceiveData
 1936 0010 0346     		mov	r3, r0
 600:../src/spark_wiring.c **** }
 1937              		.loc 1 600 0
 1938 0012 1846     		mov	r0, r3
 1939 0014 80BD     		pop	{r7, pc}
 1940              		.cfi_endproc
 1941              	.LFE75:
 1943 0016 00BF     		.section	.text.serial1_write,"ax",%progbits
 1944              		.align	2
 1945              		.global	serial1_write
 1946              		.thumb
 1947              		.thumb_func
 1949              	serial1_write:
 1950              	.LFB76:
 601:../src/spark_wiring.c **** 
 602:../src/spark_wiring.c **** void serial1_write(uint8_t Data)
 603:../src/spark_wiring.c **** {
 1951              		.loc 1 603 0
 1952              		.cfi_startproc
 1953              		@ args = 0, pretend = 0, frame = 8
 1954              		@ frame_needed = 1, uses_anonymous_args = 0
 1955 0000 80B5     		push	{r7, lr}
 1956              	.LCFI53:
 1957              		.cfi_def_cfa_offset 8
 1958              		.cfi_offset 7, -8
 1959              		.cfi_offset 14, -4
 1960 0002 82B0     		sub	sp, sp, #8
 1961              	.LCFI54:
 1962              		.cfi_def_cfa_offset 16
 1963 0004 00AF     		add	r7, sp, #0
 1964              	.LCFI55:
 1965              		.cfi_def_cfa_register 7
 1966 0006 0346     		mov	r3, r0
 1967 0008 FB71     		strb	r3, [r7, #7]
 604:../src/spark_wiring.c **** 	// Send one byte from USART
 605:../src/spark_wiring.c **** 	USART_SendData(USART2, Data);
 1968              		.loc 1 605 0
 1969 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1970 000c 9BB2     		uxth	r3, r3
 1971 000e 4FF48840 		mov	r0, #17408
 1972 0012 C4F20000 		movt	r0, 16384
 1973 0016 1946     		mov	r1, r3
 1974 0018 FFF7FEFF 		bl	USART_SendData
 606:../src/spark_wiring.c **** 
 607:../src/spark_wiring.c **** 	// Loop until USART DR register is empty
 608:../src/spark_wiring.c **** 	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
 1975              		.loc 1 608 0
 1976 001c 00BF     		nop
 1977              	.L85:
 1978              		.loc 1 608 0 is_stmt 0 discriminator 1
 1979 001e 4FF48840 		mov	r0, #17408
 1980 0022 C4F20000 		movt	r0, 16384
 1981 0026 4FF08001 		mov	r1, #128
 1982 002a FFF7FEFF 		bl	USART_GetFlagStatus
 1983 002e 0346     		mov	r3, r0
 1984 0030 002B     		cmp	r3, #0
 1985 0032 F4D0     		beq	.L85
 609:../src/spark_wiring.c **** 	{
 610:../src/spark_wiring.c **** 	}
 611:../src/spark_wiring.c **** }
 1986              		.loc 1 611 0 is_stmt 1
 1987 0034 07F10807 		add	r7, r7, #8
 1988 0038 BD46     		mov	sp, r7
 1989 003a 80BD     		pop	{r7, pc}
 1990              		.cfi_endproc
 1991              	.LFE76:
 1993              		.section	.text.serial1_print,"ax",%progbits
 1994              		.align	2
 1995              		.global	serial1_print
 1996              		.thumb
 1997              		.thumb_func
 1999              	serial1_print:
 2000              	.LFB77:
 612:../src/spark_wiring.c **** 
 613:../src/spark_wiring.c **** void serial1_print(const char * str)
 614:../src/spark_wiring.c **** {
 2001              		.loc 1 614 0
 2002              		.cfi_startproc
 2003              		@ args = 0, pretend = 0, frame = 8
 2004              		@ frame_needed = 1, uses_anonymous_args = 0
 2005 0000 80B5     		push	{r7, lr}
 2006              	.LCFI56:
 2007              		.cfi_def_cfa_offset 8
 2008              		.cfi_offset 7, -8
 2009              		.cfi_offset 14, -4
 2010 0002 82B0     		sub	sp, sp, #8
 2011              	.LCFI57:
 2012              		.cfi_def_cfa_offset 16
 2013 0004 00AF     		add	r7, sp, #0
 2014              	.LCFI58:
 2015              		.cfi_def_cfa_register 7
 2016 0006 7860     		str	r0, [r7, #4]
 615:../src/spark_wiring.c **** 	while (*str)
 2017              		.loc 1 615 0
 2018 0008 08E0     		b	.L87
 2019              	.L88:
 616:../src/spark_wiring.c **** 	{
 617:../src/spark_wiring.c **** 		serial1_write(*str++);
 2020              		.loc 1 617 0
 2021 000a 7B68     		ldr	r3, [r7, #4]
 2022 000c 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2023 000e 7A68     		ldr	r2, [r7, #4]
 2024 0010 02F10102 		add	r2, r2, #1
 2025 0014 7A60     		str	r2, [r7, #4]
 2026 0016 1846     		mov	r0, r3
 2027 0018 FFF7FEFF 		bl	serial1_write
 2028              	.L87:
 615:../src/spark_wiring.c **** 	while (*str)
 2029              		.loc 1 615 0 discriminator 1
 2030 001c 7B68     		ldr	r3, [r7, #4]
 2031 001e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2032 0020 002B     		cmp	r3, #0
 2033 0022 F2D1     		bne	.L88
 618:../src/spark_wiring.c **** 	}
 619:../src/spark_wiring.c **** }
 2034              		.loc 1 619 0
 2035 0024 07F10807 		add	r7, r7, #8
 2036 0028 BD46     		mov	sp, r7
 2037 002a 80BD     		pop	{r7, pc}
 2038              		.cfi_endproc
 2039              	.LFE77:
 2041              		.section	.text.serial1_println,"ax",%progbits
 2042              		.align	2
 2043              		.global	serial1_println
 2044              		.thumb
 2045              		.thumb_func
 2047              	serial1_println:
 2048              	.LFB78:
 620:../src/spark_wiring.c **** 
 621:../src/spark_wiring.c **** void serial1_println(const char * str)
 622:../src/spark_wiring.c **** {
 2049              		.loc 1 622 0
 2050              		.cfi_startproc
 2051              		@ args = 0, pretend = 0, frame = 8
 2052              		@ frame_needed = 1, uses_anonymous_args = 0
 2053 0000 80B5     		push	{r7, lr}
 2054              	.LCFI59:
 2055              		.cfi_def_cfa_offset 8
 2056              		.cfi_offset 7, -8
 2057              		.cfi_offset 14, -4
 2058 0002 82B0     		sub	sp, sp, #8
 2059              	.LCFI60:
 2060              		.cfi_def_cfa_offset 16
 2061 0004 00AF     		add	r7, sp, #0
 2062              	.LCFI61:
 2063              		.cfi_def_cfa_register 7
 2064 0006 7860     		str	r0, [r7, #4]
 623:../src/spark_wiring.c **** 	serial1_print(str);
 2065              		.loc 1 623 0
 2066 0008 7868     		ldr	r0, [r7, #4]
 2067 000a FFF7FEFF 		bl	serial1_print
 624:../src/spark_wiring.c **** 	serial1_print("\r\n");
 2068              		.loc 1 624 0
 2069 000e 40F20000 		movw	r0, #:lower16:.LC0
 2070 0012 C0F20000 		movt	r0, #:upper16:.LC0
 2071 0016 FFF7FEFF 		bl	serial1_print
 625:../src/spark_wiring.c **** }
 2072              		.loc 1 625 0
 2073 001a 07F10807 		add	r7, r7, #8
 2074 001e BD46     		mov	sp, r7
 2075 0020 80BD     		pop	{r7, pc}
 2076              		.cfi_endproc
 2077              	.LFE78:
 2079 0022 00BF     		.text
 2080              	.Letext0:
 2081              		.file 2 "/usr/local/gcc-arm-none-eabi-4_7-2013q1/bin/../lib/gcc/arm-none-eabi/4.7.3/../../../../ar
 2082              		.file 3 "/Users/zac/code/spark/marvin/libraries/CMSIS/Device/ST/STM32F10x/Include/stm32f10x.h"
 2083              		.file 4 "/Users/zac/code/spark/marvin/libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h"
 2084              		.file 5 "/Users/zac/code/spark/marvin/libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h"
 2085              		.file 6 "/Users/zac/code/spark/marvin/libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h"
 2086              		.file 7 "/Users/zac/code/spark/marvin/libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h"
 2087              		.file 8 "/Users/zac/code/spark/marvin/inc/spark_wiring.h"
 2088              		.file 9 "/Users/zac/code/spark/marvin/libraries/CMSIS/Include/core_cm3.h"
 2089              		.file 10 "/Users/zac/code/spark/marvin/libraries/CMSIS/Device/ST/STM32F10x/Include/system_stm32f10
DEFINED SYMBOLS
                            *ABS*:0000000000000000 spark_wiring.c
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:22     .data:0000000000000000 adcInitFirstTime
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:27     .data:0000000000000001 adcChannelConfigured
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:32     .data:0000000000000002 digitalPinModeSaved
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:38     .bss:0000000000000000 serial1_enabled
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:39     .bss:0000000000000000 $d
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:45     .data:0000000000000004 PIN_MAP
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:42     .data:0000000000000003 $d
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:218    .data:0000000000000154 Serial
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1516   .text.serial_begin:0000000000000000 serial_begin
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1550   .text.serial_end:0000000000000000 serial_end
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1577   .text.serial_available:0000000000000000 serial_available
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1606   .text.serial_read:0000000000000000 serial_read
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1635   .text.serial_write:0000000000000000 serial_write
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1671   .text.serial_print:0000000000000000 serial_print
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1723   .text.serial_println:0000000000000000 serial_println
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:230    .data:0000000000000170 Serial1
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1761   .text.serial1_begin:0000000000000000 serial1_begin
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1842   .text.serial1_end:0000000000000000 serial1_end
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1877   .text.serial1_available:0000000000000000 serial1_available
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1918   .text.serial1_read:0000000000000000 serial1_read
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1949   .text.serial1_write:0000000000000000 serial1_write
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1999   .text.serial1_print:0000000000000000 serial1_print
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:2047   .text.serial1_println:0000000000000000 serial1_println
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:239    .text.pinMode:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:244    .text.pinMode:0000000000000000 pinMode
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:338    .text.pinMode:00000000000000ac $d
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:346    .text.pinMode:00000000000000c4 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:458    .text.digitalWrite:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:463    .text.digitalWrite:0000000000000000 digitalWrite
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:624    .text.digitalRead:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:629    .text.digitalRead:0000000000000000 digitalRead
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:757    .text.ADCInit:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:762    .text.ADCInit:0000000000000000 ADCInit
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:855    .text.analogRead:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:860    .text.analogRead:0000000000000000 analogRead
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1034   .text.analogWrite:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1039   .text.analogWrite:0000000000000000 analogWrite
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1413   .text.millis:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1418   .text.millis:0000000000000000 millis
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1445   .text.delay:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1450   .text.delay:0000000000000000 delay
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1479   .text.delayMicroseconds:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1484   .text.delayMicroseconds:0000000000000000 delayMicroseconds
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1511   .text.serial_begin:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1545   .text.serial_end:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1572   .text.serial_available:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1601   .text.serial_read:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1630   .text.serial_write:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1666   .text.serial_print:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1714   .rodata:0000000000000000 $d
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1715   .rodata:0000000000000000 .LC0
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1718   .text.serial_println:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1756   .text.serial1_begin:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1837   .text.serial1_end:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1872   .text.serial1_available:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1913   .text.serial1_read:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1944   .text.serial1_write:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:1994   .text.serial1_print:0000000000000000 $t
/var/folders/d1/846xqcps64v4wybnmd7kk8540000gn/T//ccGVdKMk.s:2042   .text.serial1_println:0000000000000000 $t
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.1.8991b0b359e9e91a82acb66692cb6642
                           .group:0000000000000000 wm4.stm32f10x.h.57.69ab29c83f735418a543aa508b559235
                           .group:0000000000000000 wm4.core_cm3.h.32.8e21fbd14bb96c2b40e026c4d2c8fe1f
                           .group:0000000000000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:0000000000000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:0000000000000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:0000000000000000 wm4._ansi.h.23.b5bb84d7ba97d82b5b1dc1826a7ae811
                           .group:0000000000000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:0000000000000000 wm4.core_cmInstr.h.25.d8165482ef3061013a2fc83e2d85f3d9
                           .group:0000000000000000 wm4.core_cm3.h.129.e08b7204181ea22e6a9fa84cb9ad0924
                           .group:0000000000000000 wm4.stm32f10x.h.532.91bd57525f6c583f00129a351847d405
                           .group:0000000000000000 wm4.stm32f10x_adc.h.89.9f2b285fa0070185d48a05b61a05798c
                           .group:0000000000000000 wm4.stm32f10x_bkp.h.31.74a586c036c8ee5d9205c6728cc8d6ab
                           .group:0000000000000000 wm4.stm32f10x_dma.h.31.ef16218235edc52b414c0353f44b4bf0
                           .group:0000000000000000 wm4.stm32f10x_exti.h.31.b25bcb4f1a2daad39d2d7dfa4e901646
                           .group:0000000000000000 wm4.stm32f10x_flash.h.31.0203bc95b65c5396b67991e07a675efb
                           .group:0000000000000000 wm4.stm32f10x_gpio.h.31.0a32659dbac1fc1055c7cbdc248963be
                           .group:0000000000000000 wm4.stm32f10x_i2c.h.31.93d7dc2d477856f119d957730d4c6f1c
                           .group:0000000000000000 wm4.stm32f10x_pwr.h.31.9168b6921e0cf03b467c7ed90861c701
                           .group:0000000000000000 wm4.stm32f10x_rcc.h.31.2ee3219a25ef4ced658f2fe9d8cd94aa
                           .group:0000000000000000 wm4.stm32f10x_rtc.h.31.00ba78fc0dbb06b6e6783a1e7fccf5a0
                           .group:0000000000000000 wm4.stm32f10x_spi.h.31.d2f6e4626887cabe8c98f3a185590a36
                           .group:0000000000000000 wm4.stm32f10x_tim.h.31.6c06f7f26e0864f9cd59597f46ca2c7c
                           .group:0000000000000000 wm4.stm32f10x_usart.h.31.28d75d6af05cefbbfa00cf30a7c8a335
                           .group:0000000000000000 wm4.misc.h.31.a89fba2040036f6f8c835a78a213e0cd
                           .group:0000000000000000 wm4.stm32f10x.h.8356.9fd2fa84655112ac7dfc5c88beeb383d
                           .group:0000000000000000 wm4.spark_wiring.h.17.0130f458304c74456341a971e255779e

UNDEFINED SYMBOLS
RCC_APB2PeriphClockCmd
GPIO_Init
GPIO_ReadInputDataBit
RCC_ADCCLKConfig
ADC_DeInit
ADC_Init
ADC_Cmd
ADC_ResetCalibration
ADC_GetResetCalibrationStatus
ADC_StartCalibration
ADC_GetCalibrationStatus
ADC_RegularChannelConfig
ADC_SoftwareStartConvCmd
ADC_GetFlagStatus
ADC_GetConversionValue
SystemCoreClock
RCC_APB1PeriphClockCmd
TIM_TimeBaseInit
TIM_OC1Init
TIM_OC1PreloadConfig
TIM_OC2Init
TIM_OC2PreloadConfig
TIM_OC3Init
TIM_OC3PreloadConfig
TIM_OC4Init
TIM_OC4PreloadConfig
TIM_ARRPreloadConfig
TIM_Cmd
TimingMillis
Delay
USB_USART_Init
USB_USART_Available_Data
USB_USART_Receive_Data
USB_USART_Send_Data
USART_Init
USART_Cmd
USART_GetFlagStatus
USART_ReceiveData
USART_SendData
